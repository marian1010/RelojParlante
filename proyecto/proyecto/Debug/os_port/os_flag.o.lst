   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"os_flag.c"
  21              	.Ltext0:
  22              		.file 1 "../os_port/os_flag.c"
 1662              		.align	2
 1663              		.global	OSFlagAccept
 1665              	OSFlagAccept:
 1666              	.LFB0:
   1:../os_port/os_flag.c **** /*
   2:../os_port/os_flag.c **** ***************************************************************************************************
   3:../os_port/os_flag.c **** *                                                uC/OS-II
   4:../os_port/os_flag.c **** *                                          The Real-Time Kernel
   5:../os_port/os_flag.c **** *                                         EVENT FLAG  MANAGEMENT
   6:../os_port/os_flag.c **** *
   7:../os_port/os_flag.c **** *                          (c) Copyright 2001-2003, Jean J. Labrosse, Weston, FL
   8:../os_port/os_flag.c **** *                                           All Rights Reserved
   9:../os_port/os_flag.c **** *
  10:../os_port/os_flag.c **** * File    : OS_FLAG.C
  11:../os_port/os_flag.c **** * By      : Jean J. Labrosse
  12:../os_port/os_flag.c **** * Version : V2.76
  13:../os_port/os_flag.c **** ***************************************************************************************************
  14:../os_port/os_flag.c **** */
  15:../os_port/os_flag.c **** 
  16:../os_port/os_flag.c **** #ifndef  OS_MASTER_FILE
  17:../os_port/os_flag.c **** #include "ucos_ii.h"
  18:../os_port/os_flag.c **** #endif
  19:../os_port/os_flag.c **** 
  20:../os_port/os_flag.c **** #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
  21:../os_port/os_flag.c **** /*
  22:../os_port/os_flag.c **** ***************************************************************************************************
  23:../os_port/os_flag.c **** *                                            LOCAL PROTOTYPES
  24:../os_port/os_flag.c **** ***************************************************************************************************
  25:../os_port/os_flag.c **** */
  26:../os_port/os_flag.c **** 
  27:../os_port/os_flag.c **** static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_ty
  28:../os_port/os_flag.c **** static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy);
  29:../os_port/os_flag.c **** 
  30:../os_port/os_flag.c **** /*$PAGE*/
  31:../os_port/os_flag.c **** /*
  32:../os_port/os_flag.c **** ***************************************************************************************************
  33:../os_port/os_flag.c **** *                              CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
  34:../os_port/os_flag.c **** *
  35:../os_port/os_flag.c **** * Description: This function is called to check the status of a combination of bits to be set or cl
  36:../os_port/os_flag.c **** *              in an event flag group.  Your application can check for ANY bit to be set/cleared or
  37:../os_port/os_flag.c **** *              bits to be set/cleared.
  38:../os_port/os_flag.c **** *
  39:../os_port/os_flag.c **** *              This call does not block if the desired flags are not present.
  40:../os_port/os_flag.c **** *
  41:../os_port/os_flag.c **** * Arguments  : pgrp          is a pointer to the desired event flag group.
  42:../os_port/os_flag.c **** *
  43:../os_port/os_flag.c **** *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to chec
  44:../os_port/os_flag.c **** *                            The bits you want are specified by setting the corresponding bits in
  45:../os_port/os_flag.c **** *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
  46:../os_port/os_flag.c **** *                            'flags' would contain 0x03.
  47:../os_port/os_flag.c **** *
  48:../os_port/os_flag.c **** *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bi
  49:../os_port/os_flag.c **** *                            to be set/cleared.
  50:../os_port/os_flag.c **** *                            You can specify the following argument:
  51:../os_port/os_flag.c **** *
  52:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear 
  53:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear 
  54:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   
  55:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   
  56:../os_port/os_flag.c **** *
  57:../os_port/os_flag.c **** *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' 
  58:../os_port/os_flag.c **** *                                  the call.  Example, to wait for any flag in a group AND then cle
  59:../os_port/os_flag.c **** *                                  the flags that are present, set 'wait_type' to:
  60:../os_port/os_flag.c **** *
  61:../os_port/os_flag.c **** *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
  62:../os_port/os_flag.c **** *
  63:../os_port/os_flag.c **** *              err           is a pointer to an error code and can be:
  64:../os_port/os_flag.c **** *                            OS_NO_ERR              No error
  65:../os_port/os_flag.c **** *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
  66:../os_port/os_flag.c **** *                            OS_FLAG_ERR_WAIT_TYPE  You didn't specify a proper 'wait_type' argumen
  67:../os_port/os_flag.c **** *                            OS_FLAG_INVALID_PGRP   You passed a NULL pointer instead of the event 
  68:../os_port/os_flag.c **** *                                                   group handle.
  69:../os_port/os_flag.c **** *                            OS_FLAG_ERR_NOT_RDY    The desired flags you are waiting for are not
  70:../os_port/os_flag.c **** *                                                   available.
  71:../os_port/os_flag.c **** *
  72:../os_port/os_flag.c **** * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an 
  73:../os_port/os_flag.c **** *              occurred.
  74:../os_port/os_flag.c **** *
  75:../os_port/os_flag.c **** * Called from: Task or ISR
  76:../os_port/os_flag.c **** *
  77:../os_port/os_flag.c **** * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
  78:../os_port/os_flag.c **** *                 function NOW returns the flags that were ready INSTEAD of the current state of th
  79:../os_port/os_flag.c **** *                 event flags.
  80:../os_port/os_flag.c **** ***************************************************************************************************
  81:../os_port/os_flag.c **** */
  82:../os_port/os_flag.c **** 
  83:../os_port/os_flag.c **** #if OS_FLAG_ACCEPT_EN > 0
  84:../os_port/os_flag.c **** OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
  85:../os_port/os_flag.c **** {
 1667              		.loc 1 85 0
 1668              		.cfi_startproc
 1669              		@ Function supports interworking.
 1670              		@ args = 0, pretend = 0, frame = 24
 1671              		@ frame_needed = 1, uses_anonymous_args = 0
 1672 0000 0DC0A0E1 		mov	ip, sp
 1673              	.LCFI0:
 1674              		.cfi_def_cfa_register 12
 1675 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1676 0008 04B04CE2 		sub	fp, ip, #4
 1677              		.cfi_offset 14, -8
 1678              		.cfi_offset 13, -12
 1679              		.cfi_offset 11, -16
 1680              	.LCFI1:
 1681              		.cfi_def_cfa 11, 4
 1682 000c 18D04DE2 		sub	sp, sp, #24
 1683 0010 18000BE5 		str	r0, [fp, #-24]
 1684 0014 20300BE5 		str	r3, [fp, #-32]
 1685 0018 BA114BE1 		strh	r1, [fp, #-26]	@ movhi
 1686 001c 0230A0E1 		mov	r3, r2
 1687 0020 1B304BE5 		strb	r3, [fp, #-27]
  86:../os_port/os_flag.c ****     OS_FLAGS      flags_rdy;
  87:../os_port/os_flag.c ****     BOOLEAN       consume;
  88:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status regis
  89:../os_port/os_flag.c ****     OS_CPU_SR     cpu_sr;
  90:../os_port/os_flag.c **** 
  91:../os_port/os_flag.c **** 
  92:../os_port/os_flag.c **** 
  93:../os_port/os_flag.c ****     cpu_sr = 0;                                            /* Prevent compiler warning             
  94:../os_port/os_flag.c **** #endif    
  95:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
  96:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                      
 1688              		.loc 1 96 0
 1689 0024 18301BE5 		ldr	r3, [fp, #-24]
 1690 0028 000053E3 		cmp	r3, #0
 1691 002c 0400001A 		bne	.L2
  97:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 1692              		.loc 1 97 0
 1693 0030 20301BE5 		ldr	r3, [fp, #-32]
 1694 0034 6920E0E3 		mvn	r2, #105
 1695 0038 0020C3E5 		strb	r2, [r3, #0]
  98:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 1696              		.loc 1 98 0
 1697 003c 0030A0E3 		mov	r3, #0
 1698 0040 B30000EA 		b	.L3
 1699              	.L2:
  99:../os_port/os_flag.c ****     }
 100:../os_port/os_flag.c **** #endif
 101:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type            
 1700              		.loc 1 101 0
 1701 0044 18301BE5 		ldr	r3, [fp, #-24]
 1702 0048 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1703 004c 050053E3 		cmp	r3, #5
 1704 0050 0400000A 		beq	.L4
 102:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 1705              		.loc 1 102 0
 1706 0054 20301BE5 		ldr	r3, [fp, #-32]
 1707 0058 0120A0E3 		mov	r2, #1
 1708 005c 0020C3E5 		strb	r2, [r3, #0]
 103:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 1709              		.loc 1 103 0
 1710 0060 0030A0E3 		mov	r3, #0
 1711 0064 AA0000EA 		b	.L3
 1712              	.L4:
 104:../os_port/os_flag.c ****     }
 105:../os_port/os_flag.c ****     if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags  
 1713              		.loc 1 105 0
 1714 0068 1B305BE5 		ldrb	r3, [fp, #-27]	@ zero_extendqisi2
 1715 006c 033CA0E1 		mov	r3, r3, asl #24
 1716 0070 433CA0E1 		mov	r3, r3, asr #24
 1717 0074 000053E3 		cmp	r3, #0
 1718 0078 050000AA 		bge	.L5
 106:../os_port/os_flag.c ****         wait_type &= ~OS_FLAG_CONSUME;
 1719              		.loc 1 106 0
 1720 007c 1B305BE5 		ldrb	r3, [fp, #-27]
 1721 0080 7F3003E2 		and	r3, r3, #127
 1722 0084 1B304BE5 		strb	r3, [fp, #-27]
 107:../os_port/os_flag.c ****         consume    = TRUE;
 1723              		.loc 1 107 0
 1724 0088 0130A0E3 		mov	r3, #1
 1725 008c 0F304BE5 		strb	r3, [fp, #-15]
 1726 0090 010000EA 		b	.L6
 1727              	.L5:
 108:../os_port/os_flag.c ****     } else {
 109:../os_port/os_flag.c ****         consume    = FALSE;
 1728              		.loc 1 109 0
 1729 0094 0030A0E3 		mov	r3, #0
 1730 0098 0F304BE5 		strb	r3, [fp, #-15]
 1731              	.L6:
 110:../os_port/os_flag.c ****     }
 111:../os_port/os_flag.c **** /*$PAGE*/
 112:../os_port/os_flag.c ****     *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwis
 1732              		.loc 1 112 0
 1733 009c 20301BE5 		ldr	r3, [fp, #-32]
 1734 00a0 0020A0E3 		mov	r2, #0
 1735 00a4 0020C3E5 		strb	r2, [r3, #0]
 113:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 1736              		.loc 1 113 0
 1737              	@ 113 "../os_port/os_flag.c" 1
 1738 00a8 00000FE1 		mrs   r0, cpsr
 1739              	@ 0 "" 2
 1740              	@ 113 "../os_port/os_flag.c" 1
 1741 00ac 04002DE5 		stmfd sp!, {r0}
 1742              	@ 0 "" 2
 1743              	@ 113 "../os_port/os_flag.c" 1
 1744 00b0 C00080E3 		orr   r0, r0, #0b11000000
 1745              	@ 0 "" 2
 1746              	@ 113 "../os_port/os_flag.c" 1
 1747 00b4 00F021E1 		msr   cpsr_c, r0
 1748              	@ 0 "" 2
 114:../os_port/os_flag.c ****     switch (wait_type) {
 1749              		.loc 1 114 0
 1750 00b8 1B305BE5 		ldrb	r3, [fp, #-27]	@ zero_extendqisi2
 1751 00bc 030053E3 		cmp	r3, #3
 1752 00c0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1753 00c4 890000EA 		b	.L7
 1754              	.L12:
 1755 00c8 E4010000 		.word	.L8
 1756 00cc 6C020000 		.word	.L9
 1757 00d0 D8000000 		.word	.L10
 1758 00d4 60010000 		.word	.L11
 1759              	.L10:
 115:../os_port/os_flag.c ****         case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set    
 116:../os_port/os_flag.c ****              flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want        
 1760              		.loc 1 116 0
 1761 00d8 18301BE5 		ldr	r3, [fp, #-24]
 1762 00dc B820D3E1 		ldrh	r2, [r3, #8]
 1763 00e0 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 1764 00e4 033002E0 		and	r3, r2, r3
 1765 00e8 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 117:../os_port/os_flag.c ****              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want 
 1766              		.loc 1 117 0
 1767 00ec BE205BE1 		ldrh	r2, [fp, #-14]
 1768 00f0 BA315BE1 		ldrh	r3, [fp, #-26]
 1769 00f4 030052E1 		cmp	r2, r3
 1770 00f8 1200001A 		bne	.L13
 118:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 1771              		.loc 1 118 0
 1772 00fc 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 1773 0100 010053E3 		cmp	r3, #1
 1774 0104 1200001A 		bne	.L14
 119:../os_port/os_flag.c ****                      pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted  
 1775              		.loc 1 119 0
 1776 0108 18301BE5 		ldr	r3, [fp, #-24]
 1777 010c B830D3E1 		ldrh	r3, [r3, #8]
 1778 0110 0338A0E1 		mov	r3, r3, asl #16
 1779 0114 2328A0E1 		mov	r2, r3, lsr #16
 1780 0118 BE305BE1 		ldrh	r3, [fp, #-14]
 1781 011c 0330E0E1 		mvn	r3, r3
 1782 0120 0338A0E1 		mov	r3, r3, asl #16
 1783 0124 2338A0E1 		mov	r3, r3, lsr #16
 1784 0128 033002E0 		and	r3, r2, r3
 1785 012c 0338A0E1 		mov	r3, r3, asl #16
 1786 0130 2338A0E1 		mov	r3, r3, lsr #16
 1787 0134 0338A0E1 		mov	r3, r3, asl #16
 1788 0138 2328A0E1 		mov	r2, r3, lsr #16
 1789 013c 18301BE5 		ldr	r3, [fp, #-24]
 1790 0140 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 1791 0144 020000EA 		b	.L14
 1792              	.L13:
 120:../os_port/os_flag.c ****                  }
 121:../os_port/os_flag.c ****              } else {
 122:../os_port/os_flag.c ****                  *err  = OS_FLAG_ERR_NOT_RDY;
 1793              		.loc 1 122 0
 1794 0148 20301BE5 		ldr	r3, [fp, #-32]
 1795 014c 6720E0E3 		mvn	r2, #103
 1796 0150 0020C3E5 		strb	r2, [r3, #0]
 1797              	.L14:
 123:../os_port/os_flag.c ****              }
 124:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 1798              		.loc 1 124 0
 1799              	@ 124 "../os_port/os_flag.c" 1
 1800 0154 04009DE4 		ldmfd sp!, {r0}
 1801              	@ 0 "" 2
 1802              	@ 124 "../os_port/os_flag.c" 1
 1803 0158 00F021E1 		msr   cpsr_c, r0
 1804              	@ 0 "" 2
 125:../os_port/os_flag.c ****              break;
 1805              		.loc 1 125 0
 1806 015c 6B0000EA 		b	.L15
 1807              	.L11:
 126:../os_port/os_flag.c **** 
 127:../os_port/os_flag.c ****         case OS_FLAG_WAIT_SET_ANY:
 128:../os_port/os_flag.c ****              flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want        
 1808              		.loc 1 128 0
 1809 0160 18301BE5 		ldr	r3, [fp, #-24]
 1810 0164 B820D3E1 		ldrh	r2, [r3, #8]
 1811 0168 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 1812 016c 033002E0 		and	r3, r2, r3
 1813 0170 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 129:../os_port/os_flag.c ****              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                  
 1814              		.loc 1 129 0
 1815 0174 BE305BE1 		ldrh	r3, [fp, #-14]
 1816 0178 000053E3 		cmp	r3, #0
 1817 017c 1200000A 		beq	.L16
 130:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 1818              		.loc 1 130 0
 1819 0180 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 1820 0184 010053E3 		cmp	r3, #1
 1821 0188 1200001A 		bne	.L17
 131:../os_port/os_flag.c ****                      pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got     
 1822              		.loc 1 131 0
 1823 018c 18301BE5 		ldr	r3, [fp, #-24]
 1824 0190 B830D3E1 		ldrh	r3, [r3, #8]
 1825 0194 0338A0E1 		mov	r3, r3, asl #16
 1826 0198 2328A0E1 		mov	r2, r3, lsr #16
 1827 019c BE305BE1 		ldrh	r3, [fp, #-14]
 1828 01a0 0330E0E1 		mvn	r3, r3
 1829 01a4 0338A0E1 		mov	r3, r3, asl #16
 1830 01a8 2338A0E1 		mov	r3, r3, lsr #16
 1831 01ac 033002E0 		and	r3, r2, r3
 1832 01b0 0338A0E1 		mov	r3, r3, asl #16
 1833 01b4 2338A0E1 		mov	r3, r3, lsr #16
 1834 01b8 0338A0E1 		mov	r3, r3, asl #16
 1835 01bc 2328A0E1 		mov	r2, r3, lsr #16
 1836 01c0 18301BE5 		ldr	r3, [fp, #-24]
 1837 01c4 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 1838 01c8 020000EA 		b	.L17
 1839              	.L16:
 132:../os_port/os_flag.c ****                  }
 133:../os_port/os_flag.c ****              } else {
 134:../os_port/os_flag.c ****                  *err  = OS_FLAG_ERR_NOT_RDY;
 1840              		.loc 1 134 0
 1841 01cc 20301BE5 		ldr	r3, [fp, #-32]
 1842 01d0 6720E0E3 		mvn	r2, #103
 1843 01d4 0020C3E5 		strb	r2, [r3, #0]
 1844              	.L17:
 135:../os_port/os_flag.c ****              }
 136:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 1845              		.loc 1 136 0
 1846              	@ 136 "../os_port/os_flag.c" 1
 1847 01d8 04009DE4 		ldmfd sp!, {r0}
 1848              	@ 0 "" 2
 1849              	@ 136 "../os_port/os_flag.c" 1
 1850 01dc 00F021E1 		msr   cpsr_c, r0
 1851              	@ 0 "" 2
 137:../os_port/os_flag.c ****              break;
 1852              		.loc 1 137 0
 1853 01e0 4A0000EA 		b	.L15
 1854              	.L8:
 138:../os_port/os_flag.c **** 
 139:../os_port/os_flag.c **** #if OS_FLAG_WAIT_CLR_EN > 0
 140:../os_port/os_flag.c ****         case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared
 141:../os_port/os_flag.c ****              flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want        
 1855              		.loc 1 141 0
 1856 01e4 18301BE5 		ldr	r3, [fp, #-24]
 1857 01e8 B830D3E1 		ldrh	r3, [r3, #8]
 1858 01ec 0338A0E1 		mov	r3, r3, asl #16
 1859 01f0 2338A0E1 		mov	r3, r3, lsr #16
 1860 01f4 0330E0E1 		mvn	r3, r3
 1861 01f8 0338A0E1 		mov	r3, r3, asl #16
 1862 01fc 2328A0E1 		mov	r2, r3, lsr #16
 1863 0200 BA315BE1 		ldrh	r3, [fp, #-26]
 1864 0204 033002E0 		and	r3, r2, r3
 1865 0208 0338A0E1 		mov	r3, r3, asl #16
 1866 020c 2338A0E1 		mov	r3, r3, lsr #16
 1867 0210 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 142:../os_port/os_flag.c ****              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want 
 1868              		.loc 1 142 0
 1869 0214 BE205BE1 		ldrh	r2, [fp, #-14]
 1870 0218 BA315BE1 		ldrh	r3, [fp, #-26]
 1871 021c 030052E1 		cmp	r2, r3
 1872 0220 0B00001A 		bne	.L18
 143:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 1873              		.loc 1 143 0
 1874 0224 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 1875 0228 010053E3 		cmp	r3, #1
 1876 022c 0B00001A 		bne	.L19
 144:../os_port/os_flag.c ****                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted    
 1877              		.loc 1 144 0
 1878 0230 18301BE5 		ldr	r3, [fp, #-24]
 1879 0234 B820D3E1 		ldrh	r2, [r3, #8]
 1880 0238 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 1881 023c 033082E1 		orr	r3, r2, r3
 1882 0240 0338A0E1 		mov	r3, r3, asl #16
 1883 0244 2328A0E1 		mov	r2, r3, lsr #16
 1884 0248 18301BE5 		ldr	r3, [fp, #-24]
 1885 024c B820C3E1 		strh	r2, [r3, #8]	@ movhi
 1886 0250 020000EA 		b	.L19
 1887              	.L18:
 145:../os_port/os_flag.c ****                  }
 146:../os_port/os_flag.c ****              } else {
 147:../os_port/os_flag.c ****                  *err  = OS_FLAG_ERR_NOT_RDY;
 1888              		.loc 1 147 0
 1889 0254 20301BE5 		ldr	r3, [fp, #-32]
 1890 0258 6720E0E3 		mvn	r2, #103
 1891 025c 0020C3E5 		strb	r2, [r3, #0]
 1892              	.L19:
 148:../os_port/os_flag.c ****              }
 149:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 1893              		.loc 1 149 0
 1894              	@ 149 "../os_port/os_flag.c" 1
 1895 0260 04009DE4 		ldmfd sp!, {r0}
 1896              	@ 0 "" 2
 1897              	@ 149 "../os_port/os_flag.c" 1
 1898 0264 00F021E1 		msr   cpsr_c, r0
 1899              	@ 0 "" 2
 150:../os_port/os_flag.c ****              break;
 1900              		.loc 1 150 0
 1901 0268 280000EA 		b	.L15
 1902              	.L9:
 151:../os_port/os_flag.c **** 
 152:../os_port/os_flag.c ****         case OS_FLAG_WAIT_CLR_ANY:
 153:../os_port/os_flag.c ****              flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want        
 1903              		.loc 1 153 0
 1904 026c 18301BE5 		ldr	r3, [fp, #-24]
 1905 0270 B830D3E1 		ldrh	r3, [r3, #8]
 1906 0274 0338A0E1 		mov	r3, r3, asl #16
 1907 0278 2338A0E1 		mov	r3, r3, lsr #16
 1908 027c 0330E0E1 		mvn	r3, r3
 1909 0280 0338A0E1 		mov	r3, r3, asl #16
 1910 0284 2328A0E1 		mov	r2, r3, lsr #16
 1911 0288 BA315BE1 		ldrh	r3, [fp, #-26]
 1912 028c 033002E0 		and	r3, r2, r3
 1913 0290 0338A0E1 		mov	r3, r3, asl #16
 1914 0294 2338A0E1 		mov	r3, r3, lsr #16
 1915 0298 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 154:../os_port/os_flag.c ****              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared              
 1916              		.loc 1 154 0
 1917 029c BE305BE1 		ldrh	r3, [fp, #-14]
 1918 02a0 000053E3 		cmp	r3, #0
 1919 02a4 0B00000A 		beq	.L20
 155:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 1920              		.loc 1 155 0
 1921 02a8 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 1922 02ac 010053E3 		cmp	r3, #1
 1923 02b0 0B00001A 		bne	.L21
 156:../os_port/os_flag.c ****                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got       
 1924              		.loc 1 156 0
 1925 02b4 18301BE5 		ldr	r3, [fp, #-24]
 1926 02b8 B820D3E1 		ldrh	r2, [r3, #8]
 1927 02bc BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 1928 02c0 033082E1 		orr	r3, r2, r3
 1929 02c4 0338A0E1 		mov	r3, r3, asl #16
 1930 02c8 2328A0E1 		mov	r2, r3, lsr #16
 1931 02cc 18301BE5 		ldr	r3, [fp, #-24]
 1932 02d0 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 1933 02d4 020000EA 		b	.L21
 1934              	.L20:
 157:../os_port/os_flag.c ****                  }
 158:../os_port/os_flag.c ****              } else {
 159:../os_port/os_flag.c ****                  *err  = OS_FLAG_ERR_NOT_RDY;
 1935              		.loc 1 159 0
 1936 02d8 20301BE5 		ldr	r3, [fp, #-32]
 1937 02dc 6720E0E3 		mvn	r2, #103
 1938 02e0 0020C3E5 		strb	r2, [r3, #0]
 1939              	.L21:
 160:../os_port/os_flag.c ****              }
 161:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 1940              		.loc 1 161 0
 1941              	@ 161 "../os_port/os_flag.c" 1
 1942 02e4 04009DE4 		ldmfd sp!, {r0}
 1943              	@ 0 "" 2
 1944              	@ 161 "../os_port/os_flag.c" 1
 1945 02e8 00F021E1 		msr   cpsr_c, r0
 1946              	@ 0 "" 2
 162:../os_port/os_flag.c ****              break;
 1947              		.loc 1 162 0
 1948 02ec 070000EA 		b	.L15
 1949              	.L7:
 163:../os_port/os_flag.c **** #endif
 164:../os_port/os_flag.c **** 
 165:../os_port/os_flag.c ****         default:
 166:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 1950              		.loc 1 166 0
 1951              	@ 166 "../os_port/os_flag.c" 1
 1952 02f0 04009DE4 		ldmfd sp!, {r0}
 1953              	@ 0 "" 2
 1954              	@ 166 "../os_port/os_flag.c" 1
 1955 02f4 00F021E1 		msr   cpsr_c, r0
 1956              	@ 0 "" 2
 167:../os_port/os_flag.c ****              flags_rdy = (OS_FLAGS)0;
 1957              		.loc 1 167 0
 1958 02f8 0030A0E3 		mov	r3, #0
 1959 02fc BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 168:../os_port/os_flag.c ****              *err      = OS_FLAG_ERR_WAIT_TYPE;
 1960              		.loc 1 168 0
 1961 0300 20301BE5 		ldr	r3, [fp, #-32]
 1962 0304 6820E0E3 		mvn	r2, #104
 1963 0308 0020C3E5 		strb	r2, [r3, #0]
 169:../os_port/os_flag.c ****              break;
 1964              		.loc 1 169 0
 1965 030c 0000A0E1 		mov	r0, r0	@ nop
 1966              	.L15:
 170:../os_port/os_flag.c ****     }
 171:../os_port/os_flag.c ****     return (flags_rdy);
 1967              		.loc 1 171 0
 1968 0310 BE305BE1 		ldrh	r3, [fp, #-14]
 1969              	.L3:
 172:../os_port/os_flag.c **** }
 1970              		.loc 1 172 0
 1971 0314 0300A0E1 		mov	r0, r3
 1972 0318 0CD04BE2 		sub	sp, fp, #12
 1973 031c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1974 0320 1EFF2FE1 		bx	lr
 1975              		.cfi_endproc
 1976              	.LFE0:
 1978              		.align	2
 1979              		.global	OSFlagCreate
 1981              	OSFlagCreate:
 1982              	.LFB1:
 173:../os_port/os_flag.c **** #endif
 174:../os_port/os_flag.c **** 
 175:../os_port/os_flag.c **** /*$PAGE*/
 176:../os_port/os_flag.c **** /*
 177:../os_port/os_flag.c **** ***************************************************************************************************
 178:../os_port/os_flag.c **** *                                           CREATE AN EVENT FLAG
 179:../os_port/os_flag.c **** *
 180:../os_port/os_flag.c **** * Description: This function is called to create an event flag group.
 181:../os_port/os_flag.c **** *
 182:../os_port/os_flag.c **** * Arguments  : flags         Contains the initial value to store in the event flag group.
 183:../os_port/os_flag.c **** *
 184:../os_port/os_flag.c **** *              err           is a pointer to an error code which will be returned to your applicati
 185:../os_port/os_flag.c **** *                               OS_NO_ERR                if the call was successful.
 186:../os_port/os_flag.c **** *                               OS_ERR_CREATE_ISR        if you attempted to create an Event Flag f
 187:../os_port/os_flag.c **** *                                                        ISR.
 188:../os_port/os_flag.c **** *                               OS_FLAG_GRP_DEPLETED     if there are no more event flag groups
 189:../os_port/os_flag.c **** *
 190:../os_port/os_flag.c **** * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
 191:../os_port/os_flag.c **** *
 192:../os_port/os_flag.c **** * Called from: Task ONLY
 193:../os_port/os_flag.c **** ***************************************************************************************************
 194:../os_port/os_flag.c **** */
 195:../os_port/os_flag.c **** 
 196:../os_port/os_flag.c **** OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
 197:../os_port/os_flag.c **** {
 1983              		.loc 1 197 0
 1984              		.cfi_startproc
 1985              		@ Function supports interworking.
 1986              		@ args = 0, pretend = 0, frame = 16
 1987              		@ frame_needed = 1, uses_anonymous_args = 0
 1988 0324 0DC0A0E1 		mov	ip, sp
 1989              	.LCFI2:
 1990              		.cfi_def_cfa_register 12
 1991 0328 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1992 032c 04B04CE2 		sub	fp, ip, #4
 1993              		.cfi_offset 14, -8
 1994              		.cfi_offset 13, -12
 1995              		.cfi_offset 11, -16
 1996              	.LCFI3:
 1997              		.cfi_def_cfa 11, 4
 1998 0330 10D04DE2 		sub	sp, sp, #16
 1999 0334 0030A0E1 		mov	r3, r0
 2000 0338 1C100BE5 		str	r1, [fp, #-28]
 2001 033c B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 198:../os_port/os_flag.c ****     OS_FLAG_GRP *pgrp;
 199:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register    
 200:../os_port/os_flag.c ****     OS_CPU_SR    cpu_sr;
 201:../os_port/os_flag.c **** 
 202:../os_port/os_flag.c **** 
 203:../os_port/os_flag.c **** 
 204:../os_port/os_flag.c ****     cpu_sr = 0;                                     /* Prevent compiler warning                    
 205:../os_port/os_flag.c **** #endif    
 206:../os_port/os_flag.c ****     if (OSIntNesting > 0) {                         /* See if called from ISR ...                  
 2002              		.loc 1 206 0
 2003 0340 D8309FE5 		ldr	r3, .L27
 2004 0344 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2005 0348 000053E3 		cmp	r3, #0
 2006 034c 0400000A 		beq	.L23
 207:../os_port/os_flag.c ****         *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                
 2007              		.loc 1 207 0
 2008 0350 1C301BE5 		ldr	r3, [fp, #-28]
 2009 0354 7220E0E3 		mvn	r2, #114
 2010 0358 0020C3E5 		strb	r2, [r3, #0]
 208:../os_port/os_flag.c ****         return ((OS_FLAG_GRP *)0);
 2011              		.loc 1 208 0
 2012 035c 0030A0E3 		mov	r3, #0
 2013 0360 2A0000EA 		b	.L24
 2014              	.L23:
 209:../os_port/os_flag.c ****     }
 210:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 2015              		.loc 1 210 0
 2016              	@ 210 "../os_port/os_flag.c" 1
 2017 0364 00000FE1 		mrs   r0, cpsr
 2018              	@ 0 "" 2
 2019              	@ 210 "../os_port/os_flag.c" 1
 2020 0368 04002DE5 		stmfd sp!, {r0}
 2021              	@ 0 "" 2
 2022              	@ 210 "../os_port/os_flag.c" 1
 2023 036c C00080E3 		orr   r0, r0, #0b11000000
 2024              	@ 0 "" 2
 2025              	@ 210 "../os_port/os_flag.c" 1
 2026 0370 00F021E1 		msr   cpsr_c, r0
 2027              	@ 0 "" 2
 211:../os_port/os_flag.c ****     pgrp = OSFlagFreeList;                          /* Get next free event flag                    
 2028              		.loc 1 211 0
 2029 0374 A8309FE5 		ldr	r3, .L27+4
 2030 0378 003093E5 		ldr	r3, [r3, #0]
 2031 037c 10300BE5 		str	r3, [fp, #-16]
 212:../os_port/os_flag.c ****     if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available  
 2032              		.loc 1 212 0
 2033 0380 10301BE5 		ldr	r3, [fp, #-16]
 2034 0384 000053E3 		cmp	r3, #0
 2035 0388 1A00000A 		beq	.L25
 213:../os_port/os_flag.c ****                                                     /* Adjust free list                            
 214:../os_port/os_flag.c ****         OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 2036              		.loc 1 214 0
 2037 038c 90309FE5 		ldr	r3, .L27+4
 2038 0390 003093E5 		ldr	r3, [r3, #0]
 2039 0394 043093E5 		ldr	r3, [r3, #4]
 2040 0398 0320A0E1 		mov	r2, r3
 2041 039c 80309FE5 		ldr	r3, .L27+4
 2042 03a0 002083E5 		str	r2, [r3, #0]
 215:../os_port/os_flag.c ****         pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                
 2043              		.loc 1 215 0
 2044 03a4 10301BE5 		ldr	r3, [fp, #-16]
 2045 03a8 0520A0E3 		mov	r2, #5
 2046 03ac 0020C3E5 		strb	r2, [r3, #0]
 216:../os_port/os_flag.c ****         pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                
 2047              		.loc 1 216 0
 2048 03b0 10301BE5 		ldr	r3, [fp, #-16]
 2049 03b4 B6215BE1 		ldrh	r2, [fp, #-22]	@ movhi
 2050 03b8 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 217:../os_port/os_flag.c ****         pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags        
 2051              		.loc 1 217 0
 2052 03bc 10301BE5 		ldr	r3, [fp, #-16]
 2053 03c0 0020A0E3 		mov	r2, #0
 2054 03c4 042083E5 		str	r2, [r3, #4]
 218:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
 219:../os_port/os_flag.c ****         pgrp->OSFlagName[0]  = '?';
 2055              		.loc 1 219 0
 2056 03c8 10301BE5 		ldr	r3, [fp, #-16]
 2057 03cc 3F20A0E3 		mov	r2, #63
 2058 03d0 0A20C3E5 		strb	r2, [r3, #10]
 220:../os_port/os_flag.c ****         pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2059              		.loc 1 220 0
 2060 03d4 10301BE5 		ldr	r3, [fp, #-16]
 2061 03d8 0020A0E3 		mov	r2, #0
 2062 03dc 0B20C3E5 		strb	r2, [r3, #11]
 221:../os_port/os_flag.c **** #endif
 222:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();
 2063              		.loc 1 222 0
 2064              	@ 222 "../os_port/os_flag.c" 1
 2065 03e0 04009DE4 		ldmfd sp!, {r0}
 2066              	@ 0 "" 2
 2067              	@ 222 "../os_port/os_flag.c" 1
 2068 03e4 00F021E1 		msr   cpsr_c, r0
 2069              	@ 0 "" 2
 223:../os_port/os_flag.c ****         *err                 = OS_NO_ERR;
 2070              		.loc 1 223 0
 2071 03e8 1C301BE5 		ldr	r3, [fp, #-28]
 2072 03ec 0020A0E3 		mov	r2, #0
 2073 03f0 0020C3E5 		strb	r2, [r3, #0]
 2074 03f4 040000EA 		b	.L26
 2075              	.L25:
 224:../os_port/os_flag.c ****     } else {
 225:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();
 2076              		.loc 1 225 0
 2077              	@ 225 "../os_port/os_flag.c" 1
 2078 03f8 04009DE4 		ldmfd sp!, {r0}
 2079              	@ 0 "" 2
 2080              	@ 225 "../os_port/os_flag.c" 1
 2081 03fc 00F021E1 		msr   cpsr_c, r0
 2082              	@ 0 "" 2
 226:../os_port/os_flag.c ****         *err                 = OS_FLAG_GRP_DEPLETED;
 2083              		.loc 1 226 0
 2084 0400 1C301BE5 		ldr	r3, [fp, #-28]
 2085 0404 6520E0E3 		mvn	r2, #101
 2086 0408 0020C3E5 		strb	r2, [r3, #0]
 2087              	.L26:
 227:../os_port/os_flag.c ****     }
 228:../os_port/os_flag.c ****     return (pgrp);                                  /* Return pointer to event flag group          
 2088              		.loc 1 228 0
 2089 040c 10301BE5 		ldr	r3, [fp, #-16]
 2090              	.L24:
 229:../os_port/os_flag.c **** }
 2091              		.loc 1 229 0
 2092 0410 0300A0E1 		mov	r0, r3
 2093 0414 0CD04BE2 		sub	sp, fp, #12
 2094 0418 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2095 041c 1EFF2FE1 		bx	lr
 2096              	.L28:
 2097              		.align	2
 2098              	.L27:
 2099 0420 00000000 		.word	OSIntNesting
 2100 0424 00000000 		.word	OSFlagFreeList
 2101              		.cfi_endproc
 2102              	.LFE1:
 2104              		.align	2
 2105              		.global	OSFlagDel
 2107              	OSFlagDel:
 2108              	.LFB2:
 230:../os_port/os_flag.c **** 
 231:../os_port/os_flag.c **** /*$PAGE*/
 232:../os_port/os_flag.c **** /*
 233:../os_port/os_flag.c **** ***************************************************************************************************
 234:../os_port/os_flag.c **** *                                     DELETE AN EVENT FLAG GROUP
 235:../os_port/os_flag.c **** *
 236:../os_port/os_flag.c **** * Description: This function deletes an event flag group and readies all tasks pending on the event
 237:../os_port/os_flag.c **** *              group.
 238:../os_port/os_flag.c **** *
 239:../os_port/os_flag.c **** * Arguments  : pgrp          is a pointer to the desired event flag group.
 240:../os_port/os_flag.c **** *
 241:../os_port/os_flag.c **** *              opt           determines delete options as follows:
 242:../os_port/os_flag.c **** *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task p
 243:../os_port/os_flag.c **** *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
 244:../os_port/os_flag.c **** *                                                    waiting.  In this case, all the tasks pending 
 245:../os_port/os_flag.c **** *                                                    readied.
 246:../os_port/os_flag.c **** *
 247:../os_port/os_flag.c **** *              err           is a pointer to an error code that can contain one of the following va
 248:../os_port/os_flag.c **** *                            OS_NO_ERR               The call was successful and the event flag gro
 249:../os_port/os_flag.c **** *                                                    deleted
 250:../os_port/os_flag.c **** *                            OS_ERR_DEL_ISR          If you attempted to delete the event flag grou
 251:../os_port/os_flag.c **** *                                                    an ISR
 252:../os_port/os_flag.c **** *                            OS_FLAG_INVALID_PGRP    If 'pgrp' is a NULL pointer.
 253:../os_port/os_flag.c **** *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to an event flag 
 254:../os_port/os_flag.c **** *                            OS_ERR_INVALID_OPT      An invalid option was specified
 255:../os_port/os_flag.c **** *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the event fl
 256:../os_port/os_flag.c **** *                                                    group.
 257:../os_port/os_flag.c **** *
 258:../os_port/os_flag.c **** * Returns    : pevent        upon error
 259:../os_port/os_flag.c **** *              (OS_EVENT *)0 if the semaphore was successfully deleted.
 260:../os_port/os_flag.c **** *
 261:../os_port/os_flag.c **** * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the prese
 262:../os_port/os_flag.c **** *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend(
 263:../os_port/os_flag.c **** *              2) This call can potentially disable interrupts for a long time.  The interrupt disa
 264:../os_port/os_flag.c **** *                 time is directly proportional to the number of tasks waiting on the event flag gr
 265:../os_port/os_flag.c **** ***************************************************************************************************
 266:../os_port/os_flag.c **** */
 267:../os_port/os_flag.c **** 
 268:../os_port/os_flag.c **** #if OS_FLAG_DEL_EN > 0
 269:../os_port/os_flag.c **** OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *err)
 270:../os_port/os_flag.c **** {
 2109              		.loc 1 270 0
 2110              		.cfi_startproc
 2111              		@ Function supports interworking.
 2112              		@ args = 0, pretend = 0, frame = 24
 2113              		@ frame_needed = 1, uses_anonymous_args = 0
 2114 0428 0DC0A0E1 		mov	ip, sp
 2115              	.LCFI4:
 2116              		.cfi_def_cfa_register 12
 2117 042c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2118 0430 04B04CE2 		sub	fp, ip, #4
 2119              		.cfi_offset 14, -8
 2120              		.cfi_offset 13, -12
 2121              		.cfi_offset 11, -16
 2122              	.LCFI5:
 2123              		.cfi_def_cfa 11, 4
 2124 0434 18D04DE2 		sub	sp, sp, #24
 2125 0438 18000BE5 		str	r0, [fp, #-24]
 2126 043c 0130A0E1 		mov	r3, r1
 2127 0440 20200BE5 		str	r2, [fp, #-32]
 2128 0444 19304BE5 		strb	r3, [fp, #-25]
 271:../os_port/os_flag.c ****     BOOLEAN       tasks_waiting;
 272:../os_port/os_flag.c ****     OS_FLAG_NODE *pnode;
 273:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status regis
 274:../os_port/os_flag.c ****     OS_CPU_SR     cpu_sr;
 275:../os_port/os_flag.c **** 
 276:../os_port/os_flag.c **** 
 277:../os_port/os_flag.c **** 
 278:../os_port/os_flag.c ****     cpu_sr = 0;                                            /* Prevent compiler warning             
 279:../os_port/os_flag.c **** #endif    
 280:../os_port/os_flag.c ****     if (OSIntNesting > 0) {                                /* See if called from ISR ...           
 2129              		.loc 1 280 0
 2130 0448 10329FE5 		ldr	r3, .L44
 2131 044c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2132 0450 000053E3 		cmp	r3, #0
 2133 0454 0400000A 		beq	.L30
 281:../os_port/os_flag.c ****         *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR         
 2134              		.loc 1 281 0
 2135 0458 20301BE5 		ldr	r3, [fp, #-32]
 2136 045c 7320E0E3 		mvn	r2, #115
 2137 0460 0020C3E5 		strb	r2, [r3, #0]
 282:../os_port/os_flag.c ****         return (pgrp);
 2138              		.loc 1 282 0
 2139 0464 18301BE5 		ldr	r3, [fp, #-24]
 2140 0468 780000EA 		b	.L31
 2141              	.L30:
 283:../os_port/os_flag.c ****     }
 284:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
 285:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                      
 2142              		.loc 1 285 0
 2143 046c 18301BE5 		ldr	r3, [fp, #-24]
 2144 0470 000053E3 		cmp	r3, #0
 2145 0474 0400001A 		bne	.L32
 286:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 2146              		.loc 1 286 0
 2147 0478 20301BE5 		ldr	r3, [fp, #-32]
 2148 047c 6920E0E3 		mvn	r2, #105
 2149 0480 0020C3E5 		strb	r2, [r3, #0]
 287:../os_port/os_flag.c ****         return (pgrp);
 2150              		.loc 1 287 0
 2151 0484 18301BE5 		ldr	r3, [fp, #-24]
 2152 0488 700000EA 		b	.L31
 2153              	.L32:
 288:../os_port/os_flag.c ****     }
 289:../os_port/os_flag.c **** #endif
 290:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type            
 2154              		.loc 1 290 0
 2155 048c 18301BE5 		ldr	r3, [fp, #-24]
 2156 0490 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2157 0494 050053E3 		cmp	r3, #5
 2158 0498 0400000A 		beq	.L33
 291:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 2159              		.loc 1 291 0
 2160 049c 20301BE5 		ldr	r3, [fp, #-32]
 2161 04a0 0120A0E3 		mov	r2, #1
 2162 04a4 0020C3E5 		strb	r2, [r3, #0]
 292:../os_port/os_flag.c ****         return (pgrp);
 2163              		.loc 1 292 0
 2164 04a8 18301BE5 		ldr	r3, [fp, #-24]
 2165 04ac 670000EA 		b	.L31
 2166              	.L33:
 293:../os_port/os_flag.c ****     }
 294:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 2167              		.loc 1 294 0
 2168              	@ 294 "../os_port/os_flag.c" 1
 2169 04b0 00000FE1 		mrs   r0, cpsr
 2170              	@ 0 "" 2
 2171              	@ 294 "../os_port/os_flag.c" 1
 2172 04b4 04002DE5 		stmfd sp!, {r0}
 2173              	@ 0 "" 2
 2174              	@ 294 "../os_port/os_flag.c" 1
 2175 04b8 C00080E3 		orr   r0, r0, #0b11000000
 2176              	@ 0 "" 2
 2177              	@ 294 "../os_port/os_flag.c" 1
 2178 04bc 00F021E1 		msr   cpsr_c, r0
 2179              	@ 0 "" 2
 295:../os_port/os_flag.c ****     if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event fla
 2180              		.loc 1 295 0
 2181 04c0 18301BE5 		ldr	r3, [fp, #-24]
 2182 04c4 043093E5 		ldr	r3, [r3, #4]
 2183 04c8 000053E3 		cmp	r3, #0
 2184 04cc 0200000A 		beq	.L34
 296:../os_port/os_flag.c ****         tasks_waiting = TRUE;                              /* Yes                                  
 2185              		.loc 1 296 0
 2186 04d0 0130A0E3 		mov	r3, #1
 2187 04d4 0D304BE5 		strb	r3, [fp, #-13]
 2188 04d8 010000EA 		b	.L35
 2189              	.L34:
 297:../os_port/os_flag.c ****     } else {
 298:../os_port/os_flag.c ****         tasks_waiting = FALSE;                             /* No                                   
 2190              		.loc 1 298 0
 2191 04dc 0030A0E3 		mov	r3, #0
 2192 04e0 0D304BE5 		strb	r3, [fp, #-13]
 2193              	.L35:
 299:../os_port/os_flag.c ****     }
 300:../os_port/os_flag.c ****     switch (opt) {
 2194              		.loc 1 300 0
 2195 04e4 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 2196 04e8 000053E3 		cmp	r3, #0
 2197 04ec 0200000A 		beq	.L37
 2198 04f0 010053E3 		cmp	r3, #1
 2199 04f4 2400000A 		beq	.L38
 2200 04f8 4E0000EA 		b	.L43
 2201              	.L37:
 301:../os_port/os_flag.c ****         case OS_DEL_NO_PEND:                               /* Delete group if no task waiting      
 302:../os_port/os_flag.c ****              if (tasks_waiting == FALSE) {
 2202              		.loc 1 302 0
 2203 04fc 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2204 0500 000053E3 		cmp	r3, #0
 2205 0504 1900001A 		bne	.L39
 303:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
 304:../os_port/os_flag.c ****                  pgrp->OSFlagName[0]  = '?';               /* Unknown name                         
 2206              		.loc 1 304 0
 2207 0508 18301BE5 		ldr	r3, [fp, #-24]
 2208 050c 3F20A0E3 		mov	r2, #63
 2209 0510 0A20C3E5 		strb	r2, [r3, #10]
 305:../os_port/os_flag.c ****                  pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2210              		.loc 1 305 0
 2211 0514 18301BE5 		ldr	r3, [fp, #-24]
 2212 0518 0020A0E3 		mov	r2, #0
 2213 051c 0B20C3E5 		strb	r2, [r3, #11]
 306:../os_port/os_flag.c **** #endif
 307:../os_port/os_flag.c ****                  pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2214              		.loc 1 307 0
 2215 0520 18301BE5 		ldr	r3, [fp, #-24]
 2216 0524 0020A0E3 		mov	r2, #0
 2217 0528 0020C3E5 		strb	r2, [r3, #0]
 308:../os_port/os_flag.c ****                  pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list       
 2218              		.loc 1 308 0
 2219 052c 30319FE5 		ldr	r3, .L44+4
 2220 0530 002093E5 		ldr	r2, [r3, #0]
 2221 0534 18301BE5 		ldr	r3, [fp, #-24]
 2222 0538 042083E5 		str	r2, [r3, #4]
 309:../os_port/os_flag.c ****                  pgrp->OSFlagFlags    = (OS_FLAGS)0;
 2223              		.loc 1 309 0
 2224 053c 18301BE5 		ldr	r3, [fp, #-24]
 2225 0540 0020A0E3 		mov	r2, #0
 2226 0544 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 310:../os_port/os_flag.c ****                  OSFlagFreeList       = pgrp;
 2227              		.loc 1 310 0
 2228 0548 14319FE5 		ldr	r3, .L44+4
 2229 054c 18201BE5 		ldr	r2, [fp, #-24]
 2230 0550 002083E5 		str	r2, [r3, #0]
 311:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 2231              		.loc 1 311 0
 2232              	@ 311 "../os_port/os_flag.c" 1
 2233 0554 04009DE4 		ldmfd sp!, {r0}
 2234              	@ 0 "" 2
 2235              	@ 311 "../os_port/os_flag.c" 1
 2236 0558 00F021E1 		msr   cpsr_c, r0
 2237              	@ 0 "" 2
 312:../os_port/os_flag.c ****                  *err                 = OS_NO_ERR;
 2238              		.loc 1 312 0
 2239 055c 20301BE5 		ldr	r3, [fp, #-32]
 2240 0560 0020A0E3 		mov	r2, #0
 2241 0564 0020C3E5 		strb	r2, [r3, #0]
 313:../os_port/os_flag.c ****                  return ((OS_FLAG_GRP *)0);                /* Event Flag Group has been deleted    
 2242              		.loc 1 313 0
 2243 0568 0030A0E3 		mov	r3, #0
 2244 056c 370000EA 		b	.L31
 2245              	.L39:
 314:../os_port/os_flag.c ****              } else {
 315:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 2246              		.loc 1 315 0
 2247              	@ 315 "../os_port/os_flag.c" 1
 2248 0570 04009DE4 		ldmfd sp!, {r0}
 2249              	@ 0 "" 2
 2250              	@ 315 "../os_port/os_flag.c" 1
 2251 0574 00F021E1 		msr   cpsr_c, r0
 2252              	@ 0 "" 2
 316:../os_port/os_flag.c ****                  *err                 = OS_ERR_TASK_WAITING;
 2253              		.loc 1 316 0
 2254 0578 20301BE5 		ldr	r3, [fp, #-32]
 2255 057c 0820A0E3 		mov	r2, #8
 2256 0580 0020C3E5 		strb	r2, [r3, #0]
 317:../os_port/os_flag.c ****                  return (pgrp);
 2257              		.loc 1 317 0
 2258 0584 18301BE5 		ldr	r3, [fp, #-24]
 2259 0588 300000EA 		b	.L31
 2260              	.L38:
 318:../os_port/os_flag.c ****              }
 319:../os_port/os_flag.c **** 
 320:../os_port/os_flag.c ****         case OS_DEL_ALWAYS:                                /* Always delete the event flag group   
 321:../os_port/os_flag.c ****              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2261              		.loc 1 321 0
 2262 058c 18301BE5 		ldr	r3, [fp, #-24]
 2263 0590 043093E5 		ldr	r3, [r3, #4]
 2264 0594 14300BE5 		str	r3, [fp, #-20]
 322:../os_port/os_flag.c ****              while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags    
 2265              		.loc 1 322 0
 2266 0598 050000EA 		b	.L40
 2267              	.L41:
 323:../os_port/os_flag.c ****                  (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 2268              		.loc 1 323 0
 2269 059c 14001BE5 		ldr	r0, [fp, #-20]
 2270 05a0 0010A0E3 		mov	r1, #0
 2271 05a4 DC0300EB 		bl	OS_FlagTaskRdy
 324:../os_port/os_flag.c ****                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 2272              		.loc 1 324 0
 2273 05a8 14301BE5 		ldr	r3, [fp, #-20]
 2274 05ac 003093E5 		ldr	r3, [r3, #0]
 2275 05b0 14300BE5 		str	r3, [fp, #-20]
 2276              	.L40:
 322:../os_port/os_flag.c ****              while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags    
 2277              		.loc 1 322 0 discriminator 1
 2278 05b4 14301BE5 		ldr	r3, [fp, #-20]
 2279 05b8 000053E3 		cmp	r3, #0
 2280 05bc F6FFFF1A 		bne	.L41
 325:../os_port/os_flag.c ****              }
 326:../os_port/os_flag.c **** #if OS_EVENT_NAME_SIZE > 1
 327:../os_port/os_flag.c ****              pgrp->OSFlagName[0]  = '?';                   /* Unknown name                         
 2281              		.loc 1 327 0
 2282 05c0 18301BE5 		ldr	r3, [fp, #-24]
 2283 05c4 3F20A0E3 		mov	r2, #63
 2284 05c8 0A20C3E5 		strb	r2, [r3, #10]
 328:../os_port/os_flag.c ****              pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2285              		.loc 1 328 0
 2286 05cc 18301BE5 		ldr	r3, [fp, #-24]
 2287 05d0 0020A0E3 		mov	r2, #0
 2288 05d4 0B20C3E5 		strb	r2, [r3, #11]
 329:../os_port/os_flag.c **** #endif
 330:../os_port/os_flag.c ****              pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2289              		.loc 1 330 0
 2290 05d8 18301BE5 		ldr	r3, [fp, #-24]
 2291 05dc 0020A0E3 		mov	r2, #0
 2292 05e0 0020C3E5 		strb	r2, [r3, #0]
 331:../os_port/os_flag.c ****              pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list            
 2293              		.loc 1 331 0
 2294 05e4 78309FE5 		ldr	r3, .L44+4
 2295 05e8 002093E5 		ldr	r2, [r3, #0]
 2296 05ec 18301BE5 		ldr	r3, [fp, #-24]
 2297 05f0 042083E5 		str	r2, [r3, #4]
 332:../os_port/os_flag.c ****              pgrp->OSFlagFlags    = (OS_FLAGS)0;
 2298              		.loc 1 332 0
 2299 05f4 18301BE5 		ldr	r3, [fp, #-24]
 2300 05f8 0020A0E3 		mov	r2, #0
 2301 05fc B820C3E1 		strh	r2, [r3, #8]	@ movhi
 333:../os_port/os_flag.c ****              OSFlagFreeList       = pgrp;
 2302              		.loc 1 333 0
 2303 0600 5C309FE5 		ldr	r3, .L44+4
 2304 0604 18201BE5 		ldr	r2, [fp, #-24]
 2305 0608 002083E5 		str	r2, [r3, #0]
 334:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 2306              		.loc 1 334 0
 2307              	@ 334 "../os_port/os_flag.c" 1
 2308 060c 04009DE4 		ldmfd sp!, {r0}
 2309              	@ 0 "" 2
 2310              	@ 334 "../os_port/os_flag.c" 1
 2311 0610 00F021E1 		msr   cpsr_c, r0
 2312              	@ 0 "" 2
 335:../os_port/os_flag.c ****              if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiti
 2313              		.loc 1 335 0
 2314 0614 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2315 0618 010053E3 		cmp	r3, #1
 2316 061c 0000001A 		bne	.L42
 336:../os_port/os_flag.c ****                  OS_Sched();                               /* Find highest priority task ready to r
 2317              		.loc 1 336 0
 2318 0620 FEFFFFEB 		bl	OS_Sched
 2319              	.L42:
 337:../os_port/os_flag.c ****              }
 338:../os_port/os_flag.c ****              *err = OS_NO_ERR;
 2320              		.loc 1 338 0
 2321 0624 20301BE5 		ldr	r3, [fp, #-32]
 2322 0628 0020A0E3 		mov	r2, #0
 2323 062c 0020C3E5 		strb	r2, [r3, #0]
 339:../os_port/os_flag.c ****              return ((OS_FLAG_GRP *)0);                    /* Event Flag Group has been deleted    
 2324              		.loc 1 339 0
 2325 0630 0030A0E3 		mov	r3, #0
 2326 0634 050000EA 		b	.L31
 2327              	.L43:
 340:../os_port/os_flag.c **** 
 341:../os_port/os_flag.c ****         default:
 342:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 2328              		.loc 1 342 0
 2329              	@ 342 "../os_port/os_flag.c" 1
 2330 0638 04009DE4 		ldmfd sp!, {r0}
 2331              	@ 0 "" 2
 2332              	@ 342 "../os_port/os_flag.c" 1
 2333 063c 00F021E1 		msr   cpsr_c, r0
 2334              	@ 0 "" 2
 343:../os_port/os_flag.c ****              *err = OS_ERR_INVALID_OPT;
 2335              		.loc 1 343 0
 2336 0640 20301BE5 		ldr	r3, [fp, #-32]
 2337 0644 0720A0E3 		mov	r2, #7
 2338 0648 0020C3E5 		strb	r2, [r3, #0]
 344:../os_port/os_flag.c ****              return (pgrp);
 2339              		.loc 1 344 0
 2340 064c 18301BE5 		ldr	r3, [fp, #-24]
 2341              	.L31:
 345:../os_port/os_flag.c ****     }
 346:../os_port/os_flag.c **** }
 2342              		.loc 1 346 0
 2343 0650 0300A0E1 		mov	r0, r3
 2344 0654 0CD04BE2 		sub	sp, fp, #12
 2345 0658 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2346 065c 1EFF2FE1 		bx	lr
 2347              	.L45:
 2348              		.align	2
 2349              	.L44:
 2350 0660 00000000 		.word	OSIntNesting
 2351 0664 00000000 		.word	OSFlagFreeList
 2352              		.cfi_endproc
 2353              	.LFE2:
 2355              		.align	2
 2356              		.global	OSFlagNameGet
 2358              	OSFlagNameGet:
 2359              	.LFB3:
 347:../os_port/os_flag.c **** #endif
 348:../os_port/os_flag.c **** /*$PAGE*/
 349:../os_port/os_flag.c **** /*
 350:../os_port/os_flag.c **** ***************************************************************************************************
 351:../os_port/os_flag.c **** *                                 GET THE NAME OF AN EVENT FLAG GROUP
 352:../os_port/os_flag.c **** *
 353:../os_port/os_flag.c **** * Description: This function is used to obtain the name assigned to an event flag group
 354:../os_port/os_flag.c **** *
 355:../os_port/os_flag.c **** * Arguments  : pgrp      is a pointer to the event flag group.
 356:../os_port/os_flag.c **** *
 357:../os_port/os_flag.c **** *              pname     is a pointer to an ASCII string that will receive the name of the event fl
 358:../os_port/os_flag.c **** *                        group.  The string must be able to hold at least OS_FLAG_NAME_SIZE charact
 359:../os_port/os_flag.c **** *
 360:../os_port/os_flag.c **** *              err       is a pointer to an error code that can contain one of the following values
 361:../os_port/os_flag.c **** *
 362:../os_port/os_flag.c **** *                        OS_NO_ERR                  if the requested task is resumed
 363:../os_port/os_flag.c **** *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag gr
 364:../os_port/os_flag.c **** *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
 365:../os_port/os_flag.c **** *                        OS_FLAG_INVALID_PGRP       if you passed a NULL pointer for 'pgrp'
 366:../os_port/os_flag.c **** *
 367:../os_port/os_flag.c **** * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
 368:../os_port/os_flag.c **** ***************************************************************************************************
 369:../os_port/os_flag.c **** */
 370:../os_port/os_flag.c **** 
 371:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
 372:../os_port/os_flag.c **** INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, char *pname, INT8U *err)
 373:../os_port/os_flag.c **** {
 2360              		.loc 1 373 0
 2361              		.cfi_startproc
 2362              		@ Function supports interworking.
 2363              		@ args = 0, pretend = 0, frame = 24
 2364              		@ frame_needed = 1, uses_anonymous_args = 0
 2365 0668 0DC0A0E1 		mov	ip, sp
 2366              	.LCFI6:
 2367              		.cfi_def_cfa_register 12
 2368 066c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2369 0670 04B04CE2 		sub	fp, ip, #4
 2370              		.cfi_offset 14, -8
 2371              		.cfi_offset 13, -12
 2372              		.cfi_offset 11, -16
 2373              	.LCFI7:
 2374              		.cfi_def_cfa 11, 4
 2375 0674 18D04DE2 		sub	sp, sp, #24
 2376 0678 18000BE5 		str	r0, [fp, #-24]
 2377 067c 1C100BE5 		str	r1, [fp, #-28]
 2378 0680 20200BE5 		str	r2, [fp, #-32]
 374:../os_port/os_flag.c ****     INT8U      len;
 375:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register       
 376:../os_port/os_flag.c ****     OS_CPU_SR  cpu_sr;
 377:../os_port/os_flag.c **** 
 378:../os_port/os_flag.c **** 
 379:../os_port/os_flag.c **** 
 380:../os_port/os_flag.c ****     cpu_sr = 0;                                  /* Prevent compiler warning                       
 381:../os_port/os_flag.c **** #endif    
 382:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 2379              		.loc 1 382 0
 2380              	@ 382 "../os_port/os_flag.c" 1
 2381 0684 00000FE1 		mrs   r0, cpsr
 2382              	@ 0 "" 2
 2383              	@ 382 "../os_port/os_flag.c" 1
 2384 0688 04002DE5 		stmfd sp!, {r0}
 2385              	@ 0 "" 2
 2386              	@ 382 "../os_port/os_flag.c" 1
 2387 068c C00080E3 		orr   r0, r0, #0b11000000
 2388              	@ 0 "" 2
 2389              	@ 382 "../os_port/os_flag.c" 1
 2390 0690 00F021E1 		msr   cpsr_c, r0
 2391              	@ 0 "" 2
 383:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
 384:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                      
 2392              		.loc 1 384 0
 2393 0694 18301BE5 		ldr	r3, [fp, #-24]
 2394 0698 000053E3 		cmp	r3, #0
 2395 069c 0600001A 		bne	.L47
 385:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();                      /* Yes                                            
 2396              		.loc 1 385 0
 2397              	@ 385 "../os_port/os_flag.c" 1
 2398 06a0 04009DE4 		ldmfd sp!, {r0}
 2399              	@ 0 "" 2
 2400              	@ 385 "../os_port/os_flag.c" 1
 2401 06a4 00F021E1 		msr   cpsr_c, r0
 2402              	@ 0 "" 2
 386:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 2403              		.loc 1 386 0
 2404 06a8 20301BE5 		ldr	r3, [fp, #-32]
 2405 06ac 6920E0E3 		mvn	r2, #105
 2406 06b0 0020C3E5 		strb	r2, [r3, #0]
 387:../os_port/os_flag.c ****         return (0);
 2407              		.loc 1 387 0
 2408 06b4 0030A0E3 		mov	r3, #0
 2409 06b8 210000EA 		b	.L48
 2410              	.L47:
 388:../os_port/os_flag.c ****     }
 389:../os_port/os_flag.c ****     if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                     
 2411              		.loc 1 389 0
 2412 06bc 1C301BE5 		ldr	r3, [fp, #-28]
 2413 06c0 000053E3 		cmp	r3, #0
 2414 06c4 0600001A 		bne	.L49
 390:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();                      /* Yes                                            
 2415              		.loc 1 390 0
 2416              	@ 390 "../os_port/os_flag.c" 1
 2417 06c8 04009DE4 		ldmfd sp!, {r0}
 2418              	@ 0 "" 2
 2419              	@ 390 "../os_port/os_flag.c" 1
 2420 06cc 00F021E1 		msr   cpsr_c, r0
 2421              	@ 0 "" 2
 391:../os_port/os_flag.c ****         *err = OS_ERR_PNAME_NULL;
 2422              		.loc 1 391 0
 2423 06d0 20301BE5 		ldr	r3, [fp, #-32]
 2424 06d4 0F20A0E3 		mov	r2, #15
 2425 06d8 0020C3E5 		strb	r2, [r3, #0]
 392:../os_port/os_flag.c ****         return (0);
 2426              		.loc 1 392 0
 2427 06dc 0030A0E3 		mov	r3, #0
 2428 06e0 170000EA 		b	.L48
 2429              	.L49:
 393:../os_port/os_flag.c ****     }
 394:../os_port/os_flag.c **** #endif
 395:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 2430              		.loc 1 395 0
 2431 06e4 18301BE5 		ldr	r3, [fp, #-24]
 2432 06e8 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2433 06ec 050053E3 		cmp	r3, #5
 2434 06f0 0600000A 		beq	.L50
 396:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();
 2435              		.loc 1 396 0
 2436              	@ 396 "../os_port/os_flag.c" 1
 2437 06f4 04009DE4 		ldmfd sp!, {r0}
 2438              	@ 0 "" 2
 2439              	@ 396 "../os_port/os_flag.c" 1
 2440 06f8 00F021E1 		msr   cpsr_c, r0
 2441              	@ 0 "" 2
 397:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 2442              		.loc 1 397 0
 2443 06fc 20301BE5 		ldr	r3, [fp, #-32]
 2444 0700 0120A0E3 		mov	r2, #1
 2445 0704 0020C3E5 		strb	r2, [r3, #0]
 398:../os_port/os_flag.c ****         return (0);
 2446              		.loc 1 398 0
 2447 0708 0030A0E3 		mov	r3, #0
 2448 070c 0C0000EA 		b	.L48
 2449              	.L50:
 399:../os_port/os_flag.c ****     }
 400:../os_port/os_flag.c ****     len  = OS_StrCopy(pname, pgrp->OSFlagName);  /* Copy name from OS_FLAG_GRP                     
 2450              		.loc 1 400 0
 2451 0710 18301BE5 		ldr	r3, [fp, #-24]
 2452 0714 0A3083E2 		add	r3, r3, #10
 2453 0718 1C001BE5 		ldr	r0, [fp, #-28]
 2454 071c 0310A0E1 		mov	r1, r3
 2455 0720 FEFFFFEB 		bl	OS_StrCopy
 2456 0724 0030A0E1 		mov	r3, r0
 2457 0728 0D304BE5 		strb	r3, [fp, #-13]
 401:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 2458              		.loc 1 401 0
 2459              	@ 401 "../os_port/os_flag.c" 1
 2460 072c 04009DE4 		ldmfd sp!, {r0}
 2461              	@ 0 "" 2
 2462              	@ 401 "../os_port/os_flag.c" 1
 2463 0730 00F021E1 		msr   cpsr_c, r0
 2464              	@ 0 "" 2
 402:../os_port/os_flag.c ****     *err = OS_NO_ERR;
 2465              		.loc 1 402 0
 2466 0734 20301BE5 		ldr	r3, [fp, #-32]
 2467 0738 0020A0E3 		mov	r2, #0
 2468 073c 0020C3E5 		strb	r2, [r3, #0]
 403:../os_port/os_flag.c ****     return (len);
 2469              		.loc 1 403 0
 2470 0740 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2471              	.L48:
 404:../os_port/os_flag.c **** }
 2472              		.loc 1 404 0
 2473 0744 0300A0E1 		mov	r0, r3
 2474 0748 0CD04BE2 		sub	sp, fp, #12
 2475 074c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2476 0750 1EFF2FE1 		bx	lr
 2477              		.cfi_endproc
 2478              	.LFE3:
 2480              		.align	2
 2481              		.global	OSFlagNameSet
 2483              	OSFlagNameSet:
 2484              	.LFB4:
 405:../os_port/os_flag.c **** #endif
 406:../os_port/os_flag.c **** 
 407:../os_port/os_flag.c **** /*$PAGE*/
 408:../os_port/os_flag.c **** /*
 409:../os_port/os_flag.c **** ***************************************************************************************************
 410:../os_port/os_flag.c **** *                                 ASSIGN A NAME TO AN EVENT FLAG GROUP
 411:../os_port/os_flag.c **** *
 412:../os_port/os_flag.c **** * Description: This function assigns a name to an event flag group.
 413:../os_port/os_flag.c **** *
 414:../os_port/os_flag.c **** * Arguments  : pgrp      is a pointer to the event flag group. 
 415:../os_port/os_flag.c **** *
 416:../os_port/os_flag.c **** *              pname     is a pointer to an ASCII string that will be used as the name of the event
 417:../os_port/os_flag.c **** *                        group.  The string must be able to hold at least OS_FLAG_NAME_SIZE charact
 418:../os_port/os_flag.c **** *
 419:../os_port/os_flag.c **** *              err       is a pointer to an error code that can contain one of the following values
 420:../os_port/os_flag.c **** *
 421:../os_port/os_flag.c **** *                        OS_NO_ERR                  if the requested task is resumed
 422:../os_port/os_flag.c **** *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag gr
 423:../os_port/os_flag.c **** *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
 424:../os_port/os_flag.c **** *                        OS_FLAG_INVALID_PGRP       if you passed a NULL pointer for 'pgrp'
 425:../os_port/os_flag.c **** *
 426:../os_port/os_flag.c **** * Returns    : None
 427:../os_port/os_flag.c **** ***************************************************************************************************
 428:../os_port/os_flag.c **** */
 429:../os_port/os_flag.c **** 
 430:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
 431:../os_port/os_flag.c **** void  OSFlagNameSet (OS_FLAG_GRP *pgrp, char *pname, INT8U *err)
 432:../os_port/os_flag.c **** {
 2485              		.loc 1 432 0
 2486              		.cfi_startproc
 2487              		@ Function supports interworking.
 2488              		@ args = 0, pretend = 0, frame = 24
 2489              		@ frame_needed = 1, uses_anonymous_args = 0
 2490 0754 0DC0A0E1 		mov	ip, sp
 2491              	.LCFI8:
 2492              		.cfi_def_cfa_register 12
 2493 0758 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2494 075c 04B04CE2 		sub	fp, ip, #4
 2495              		.cfi_offset 14, -8
 2496              		.cfi_offset 13, -12
 2497              		.cfi_offset 11, -16
 2498              	.LCFI9:
 2499              		.cfi_def_cfa 11, 4
 2500 0760 18D04DE2 		sub	sp, sp, #24
 2501 0764 18000BE5 		str	r0, [fp, #-24]
 2502 0768 1C100BE5 		str	r1, [fp, #-28]
 2503 076c 20200BE5 		str	r2, [fp, #-32]
 433:../os_port/os_flag.c ****     INT8U      len;
 434:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register       
 435:../os_port/os_flag.c ****     OS_CPU_SR  cpu_sr;
 436:../os_port/os_flag.c **** 
 437:../os_port/os_flag.c **** 
 438:../os_port/os_flag.c **** 
 439:../os_port/os_flag.c ****     cpu_sr = 0;                                  /* Prevent compiler warning                       
 440:../os_port/os_flag.c **** #endif    
 441:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 2504              		.loc 1 441 0
 2505              	@ 441 "../os_port/os_flag.c" 1
 2506 0770 00000FE1 		mrs   r0, cpsr
 2507              	@ 0 "" 2
 2508              	@ 441 "../os_port/os_flag.c" 1
 2509 0774 04002DE5 		stmfd sp!, {r0}
 2510              	@ 0 "" 2
 2511              	@ 441 "../os_port/os_flag.c" 1
 2512 0778 C00080E3 		orr   r0, r0, #0b11000000
 2513              	@ 0 "" 2
 2514              	@ 441 "../os_port/os_flag.c" 1
 2515 077c 00F021E1 		msr   cpsr_c, r0
 2516              	@ 0 "" 2
 442:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
 443:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                      
 2517              		.loc 1 443 0
 2518 0780 18301BE5 		ldr	r3, [fp, #-24]
 2519 0784 000053E3 		cmp	r3, #0
 2520 0788 0500001A 		bne	.L52
 444:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();                      /* Yes                                            
 2521              		.loc 1 444 0
 2522              	@ 444 "../os_port/os_flag.c" 1
 2523 078c 04009DE4 		ldmfd sp!, {r0}
 2524              	@ 0 "" 2
 2525              	@ 444 "../os_port/os_flag.c" 1
 2526 0790 00F021E1 		msr   cpsr_c, r0
 2527              	@ 0 "" 2
 445:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 2528              		.loc 1 445 0
 2529 0794 20301BE5 		ldr	r3, [fp, #-32]
 2530 0798 6920E0E3 		mvn	r2, #105
 2531 079c 0020C3E5 		strb	r2, [r3, #0]
 446:../os_port/os_flag.c ****         return;
 2532              		.loc 1 446 0
 2533 07a0 2A0000EA 		b	.L51
 2534              	.L52:
 447:../os_port/os_flag.c ****     }
 448:../os_port/os_flag.c ****     if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                     
 2535              		.loc 1 448 0
 2536 07a4 1C301BE5 		ldr	r3, [fp, #-28]
 2537 07a8 000053E3 		cmp	r3, #0
 2538 07ac 0500001A 		bne	.L54
 449:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();                      /* Yes                                            
 2539              		.loc 1 449 0
 2540              	@ 449 "../os_port/os_flag.c" 1
 2541 07b0 04009DE4 		ldmfd sp!, {r0}
 2542              	@ 0 "" 2
 2543              	@ 449 "../os_port/os_flag.c" 1
 2544 07b4 00F021E1 		msr   cpsr_c, r0
 2545              	@ 0 "" 2
 450:../os_port/os_flag.c ****         *err = OS_ERR_PNAME_NULL;
 2546              		.loc 1 450 0
 2547 07b8 20301BE5 		ldr	r3, [fp, #-32]
 2548 07bc 0F20A0E3 		mov	r2, #15
 2549 07c0 0020C3E5 		strb	r2, [r3, #0]
 451:../os_port/os_flag.c ****         return;
 2550              		.loc 1 451 0
 2551 07c4 210000EA 		b	.L51
 2552              	.L54:
 452:../os_port/os_flag.c ****     }
 453:../os_port/os_flag.c **** #endif
 454:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 2553              		.loc 1 454 0
 2554 07c8 18301BE5 		ldr	r3, [fp, #-24]
 2555 07cc 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2556 07d0 050053E3 		cmp	r3, #5
 2557 07d4 0500000A 		beq	.L55
 455:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();
 2558              		.loc 1 455 0
 2559              	@ 455 "../os_port/os_flag.c" 1
 2560 07d8 04009DE4 		ldmfd sp!, {r0}
 2561              	@ 0 "" 2
 2562              	@ 455 "../os_port/os_flag.c" 1
 2563 07dc 00F021E1 		msr   cpsr_c, r0
 2564              	@ 0 "" 2
 456:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 2565              		.loc 1 456 0
 2566 07e0 20301BE5 		ldr	r3, [fp, #-32]
 2567 07e4 0120A0E3 		mov	r2, #1
 2568 07e8 0020C3E5 		strb	r2, [r3, #0]
 457:../os_port/os_flag.c ****         return;
 2569              		.loc 1 457 0
 2570 07ec 170000EA 		b	.L51
 2571              	.L55:
 458:../os_port/os_flag.c ****     }
 459:../os_port/os_flag.c ****     len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?     
 2572              		.loc 1 459 0
 2573 07f0 1C001BE5 		ldr	r0, [fp, #-28]
 2574 07f4 FEFFFFEB 		bl	OS_StrLen
 2575 07f8 0030A0E1 		mov	r3, r0
 2576 07fc 0D304BE5 		strb	r3, [fp, #-13]
 460:../os_port/os_flag.c ****     if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                             
 2577              		.loc 1 460 0
 2578 0800 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2579 0804 1F0053E3 		cmp	r3, #31
 2580 0808 0500009A 		bls	.L56
 461:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();
 2581              		.loc 1 461 0
 2582              	@ 461 "../os_port/os_flag.c" 1
 2583 080c 04009DE4 		ldmfd sp!, {r0}
 2584              	@ 0 "" 2
 2585              	@ 461 "../os_port/os_flag.c" 1
 2586 0810 00F021E1 		msr   cpsr_c, r0
 2587              	@ 0 "" 2
 462:../os_port/os_flag.c ****         *err = OS_ERR_FLAG_NAME_TOO_LONG;
 2588              		.loc 1 462 0
 2589 0814 20301BE5 		ldr	r3, [fp, #-32]
 2590 0818 0D20A0E3 		mov	r2, #13
 2591 081c 0020C3E5 		strb	r2, [r3, #0]
 463:../os_port/os_flag.c ****         return;
 2592              		.loc 1 463 0
 2593 0820 0A0000EA 		b	.L51
 2594              	.L56:
 464:../os_port/os_flag.c ****     } 
 465:../os_port/os_flag.c ****     (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                
 2595              		.loc 1 465 0
 2596 0824 18301BE5 		ldr	r3, [fp, #-24]
 2597 0828 0A3083E2 		add	r3, r3, #10
 2598 082c 0300A0E1 		mov	r0, r3
 2599 0830 1C101BE5 		ldr	r1, [fp, #-28]
 2600 0834 FEFFFFEB 		bl	OS_StrCopy
 466:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 2601              		.loc 1 466 0
 2602              	@ 466 "../os_port/os_flag.c" 1
 2603 0838 04009DE4 		ldmfd sp!, {r0}
 2604              	@ 0 "" 2
 2605              	@ 466 "../os_port/os_flag.c" 1
 2606 083c 00F021E1 		msr   cpsr_c, r0
 2607              	@ 0 "" 2
 467:../os_port/os_flag.c ****     *err = OS_NO_ERR;
 2608              		.loc 1 467 0
 2609 0840 20301BE5 		ldr	r3, [fp, #-32]
 2610 0844 0020A0E3 		mov	r2, #0
 2611 0848 0020C3E5 		strb	r2, [r3, #0]
 468:../os_port/os_flag.c ****     return;
 2612              		.loc 1 468 0
 2613 084c 0000A0E1 		mov	r0, r0	@ nop
 2614              	.L51:
 469:../os_port/os_flag.c **** }
 2615              		.loc 1 469 0
 2616 0850 0CD04BE2 		sub	sp, fp, #12
 2617 0854 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2618 0858 1EFF2FE1 		bx	lr
 2619              		.cfi_endproc
 2620              	.LFE4:
 2622              		.align	2
 2623              		.global	OSFlagPend
 2625              	OSFlagPend:
 2626              	.LFB5:
 470:../os_port/os_flag.c **** #endif
 471:../os_port/os_flag.c **** 
 472:../os_port/os_flag.c **** /*$PAGE*/
 473:../os_port/os_flag.c **** /*
 474:../os_port/os_flag.c **** ***************************************************************************************************
 475:../os_port/os_flag.c **** *                                        WAIT ON AN EVENT FLAG GROUP
 476:../os_port/os_flag.c **** *
 477:../os_port/os_flag.c **** * Description: This function is called to wait for a combination of bits to be set in an event flag
 478:../os_port/os_flag.c **** *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
 479:../os_port/os_flag.c **** *
 480:../os_port/os_flag.c **** * Arguments  : pgrp          is a pointer to the desired event flag group.
 481:../os_port/os_flag.c **** *
 482:../os_port/os_flag.c **** *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait
 483:../os_port/os_flag.c **** *                            The bits you want are specified by setting the corresponding bits in
 484:../os_port/os_flag.c **** *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
 485:../os_port/os_flag.c **** *                            'flags' would contain 0x03.
 486:../os_port/os_flag.c **** *
 487:../os_port/os_flag.c **** *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be
 488:../os_port/os_flag.c **** *                            You can specify the following argument:
 489:../os_port/os_flag.c **** *
 490:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clea
 491:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set 
 492:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clea
 493:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set 
 494:../os_port/os_flag.c **** *
 495:../os_port/os_flag.c **** *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' 
 496:../os_port/os_flag.c **** *                                  the call.  Example, to wait for any flag in a group AND then cle
 497:../os_port/os_flag.c **** *                                  the flags that are present, set 'wait_type' to:
 498:../os_port/os_flag.c **** *
 499:../os_port/os_flag.c **** *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
 500:../os_port/os_flag.c **** *
 501:../os_port/os_flag.c **** *              timeout       is an optional timeout (in clock ticks) that your task will wait for t
 502:../os_port/os_flag.c **** *                            desired bit combination.  If you specify 0, however, your task will wa
 503:../os_port/os_flag.c **** *                            forever at the specified event flag group or, until a message arrives.
 504:../os_port/os_flag.c **** *
 505:../os_port/os_flag.c **** *              err           is a pointer to an error code and can be:
 506:../os_port/os_flag.c **** *                            OS_NO_ERR              The desired bits have been set within the speci
 507:../os_port/os_flag.c **** *                                                   'timeout'.
 508:../os_port/os_flag.c **** *                            OS_ERR_PEND_ISR        If you tried to PEND from an ISR
 509:../os_port/os_flag.c **** *                            OS_FLAG_INVALID_PGRP   If 'pgrp' is a NULL pointer.
 510:../os_port/os_flag.c **** *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
 511:../os_port/os_flag.c **** *                            OS_TIMEOUT             The bit(s) have not been set in the specified
 512:../os_port/os_flag.c **** *                                                   'timeout'.
 513:../os_port/os_flag.c **** *                            OS_FLAG_ERR_WAIT_TYPE  You didn't specify a proper 'wait_type' argumen
 514:../os_port/os_flag.c **** *
 515:../os_port/os_flag.c **** * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an 
 516:../os_port/os_flag.c **** *              occurred.
 517:../os_port/os_flag.c **** *
 518:../os_port/os_flag.c **** * Called from: Task ONLY
 519:../os_port/os_flag.c **** *
 520:../os_port/os_flag.c **** * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
 521:../os_port/os_flag.c **** *                 function NOW returns the flags that were ready INSTEAD of the current state of th
 522:../os_port/os_flag.c **** *                 event flags.
 523:../os_port/os_flag.c **** ***************************************************************************************************
 524:../os_port/os_flag.c **** */
 525:../os_port/os_flag.c **** 
 526:../os_port/os_flag.c **** OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *er
 527:../os_port/os_flag.c **** {
 2627              		.loc 1 527 0
 2628              		.cfi_startproc
 2629              		@ Function supports interworking.
 2630              		@ args = 4, pretend = 0, frame = 40
 2631              		@ frame_needed = 1, uses_anonymous_args = 0
 2632 085c 0DC0A0E1 		mov	ip, sp
 2633              	.LCFI10:
 2634              		.cfi_def_cfa_register 12
 2635 0860 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2636 0864 04B04CE2 		sub	fp, ip, #4
 2637              		.cfi_offset 14, -8
 2638              		.cfi_offset 13, -12
 2639              		.cfi_offset 11, -16
 2640              	.LCFI11:
 2641              		.cfi_def_cfa 11, 4
 2642 0868 30D04DE2 		sub	sp, sp, #48
 2643 086c 28000BE5 		str	r0, [fp, #-40]
 2644 0870 BA124BE1 		strh	r1, [fp, #-42]	@ movhi
 2645 0874 2B204BE5 		strb	r2, [fp, #-43]
 2646 0878 BE324BE1 		strh	r3, [fp, #-46]	@ movhi
 528:../os_port/os_flag.c ****     OS_FLAG_NODE  node;
 529:../os_port/os_flag.c ****     OS_FLAGS      flags_rdy;
 530:../os_port/os_flag.c ****     BOOLEAN       consume;
 531:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status regis
 532:../os_port/os_flag.c ****     OS_CPU_SR     cpu_sr;
 533:../os_port/os_flag.c **** 
 534:../os_port/os_flag.c **** 
 535:../os_port/os_flag.c **** 
 536:../os_port/os_flag.c ****     cpu_sr = 0;                                            /* Prevent compiler warning             
 537:../os_port/os_flag.c **** #endif    
 538:../os_port/os_flag.c ****     if (OSIntNesting > 0) {                                /* See if called from ISR ...           
 2647              		.loc 1 538 0
 2648 087c 3C359FE5 		ldr	r3, .L85
 2649 0880 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2650 0884 000053E3 		cmp	r3, #0
 2651 0888 0400000A 		beq	.L58
 539:../os_port/os_flag.c ****         *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR           
 2652              		.loc 1 539 0
 2653 088c 04309BE5 		ldr	r3, [fp, #4]
 2654 0890 0220A0E3 		mov	r2, #2
 2655 0894 0020C3E5 		strb	r2, [r3, #0]
 540:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 2656              		.loc 1 540 0
 2657 0898 0030A0E3 		mov	r3, #0
 2658 089c 430100EA 		b	.L59
 2659              	.L58:
 541:../os_port/os_flag.c ****     }
 542:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
 543:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                      
 2660              		.loc 1 543 0
 2661 08a0 28301BE5 		ldr	r3, [fp, #-40]
 2662 08a4 000053E3 		cmp	r3, #0
 2663 08a8 0400001A 		bne	.L60
 544:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 2664              		.loc 1 544 0
 2665 08ac 04309BE5 		ldr	r3, [fp, #4]
 2666 08b0 6920E0E3 		mvn	r2, #105
 2667 08b4 0020C3E5 		strb	r2, [r3, #0]
 545:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 2668              		.loc 1 545 0
 2669 08b8 0030A0E3 		mov	r3, #0
 2670 08bc 3B0100EA 		b	.L59
 2671              	.L60:
 546:../os_port/os_flag.c ****     }
 547:../os_port/os_flag.c **** #endif
 548:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type            
 2672              		.loc 1 548 0
 2673 08c0 28301BE5 		ldr	r3, [fp, #-40]
 2674 08c4 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2675 08c8 050053E3 		cmp	r3, #5
 2676 08cc 0400000A 		beq	.L61
 549:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 2677              		.loc 1 549 0
 2678 08d0 04309BE5 		ldr	r3, [fp, #4]
 2679 08d4 0120A0E3 		mov	r2, #1
 2680 08d8 0020C3E5 		strb	r2, [r3, #0]
 550:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 2681              		.loc 1 550 0
 2682 08dc 0030A0E3 		mov	r3, #0
 2683 08e0 320100EA 		b	.L59
 2684              	.L61:
 551:../os_port/os_flag.c ****     }
 552:../os_port/os_flag.c ****     if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags  
 2685              		.loc 1 552 0
 2686 08e4 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 2687 08e8 033CA0E1 		mov	r3, r3, asl #24
 2688 08ec 433CA0E1 		mov	r3, r3, asr #24
 2689 08f0 000053E3 		cmp	r3, #0
 2690 08f4 050000AA 		bge	.L62
 553:../os_port/os_flag.c ****         wait_type &= ~OS_FLAG_CONSUME;
 2691              		.loc 1 553 0
 2692 08f8 2B305BE5 		ldrb	r3, [fp, #-43]
 2693 08fc 7F3003E2 		and	r3, r3, #127
 2694 0900 2B304BE5 		strb	r3, [fp, #-43]
 554:../os_port/os_flag.c ****         consume    = TRUE;
 2695              		.loc 1 554 0
 2696 0904 0130A0E3 		mov	r3, #1
 2697 0908 0D304BE5 		strb	r3, [fp, #-13]
 2698 090c 010000EA 		b	.L63
 2699              	.L62:
 555:../os_port/os_flag.c ****     } else {
 556:../os_port/os_flag.c ****         consume    = FALSE;
 2700              		.loc 1 556 0
 2701 0910 0030A0E3 		mov	r3, #0
 2702 0914 0D304BE5 		strb	r3, [fp, #-13]
 2703              	.L63:
 557:../os_port/os_flag.c ****     }
 558:../os_port/os_flag.c **** /*$PAGE*/
 559:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 2704              		.loc 1 559 0
 2705              	@ 559 "../os_port/os_flag.c" 1
 2706 0918 00000FE1 		mrs   r0, cpsr
 2707              	@ 0 "" 2
 2708              	@ 559 "../os_port/os_flag.c" 1
 2709 091c 04002DE5 		stmfd sp!, {r0}
 2710              	@ 0 "" 2
 2711              	@ 559 "../os_port/os_flag.c" 1
 2712 0920 C00080E3 		orr   r0, r0, #0b11000000
 2713              	@ 0 "" 2
 2714              	@ 559 "../os_port/os_flag.c" 1
 2715 0924 00F021E1 		msr   cpsr_c, r0
 2716              	@ 0 "" 2
 560:../os_port/os_flag.c ****     switch (wait_type) {
 2717              		.loc 1 560 0
 2718 0928 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 2719 092c 030053E3 		cmp	r3, #3
 2720 0930 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2721 0934 C10000EA 		b	.L64
 2722              	.L69:
 2723 0938 C40A0000 		.word	.L65
 2724 093c 840B0000 		.word	.L66
 2725 0940 48090000 		.word	.L67
 2726 0944 080A0000 		.word	.L68
 2727              	.L67:
 561:../os_port/os_flag.c ****         case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set    
 562:../os_port/os_flag.c ****              flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want        
 2728              		.loc 1 562 0
 2729 0948 28301BE5 		ldr	r3, [fp, #-40]
 2730 094c B820D3E1 		ldrh	r2, [r3, #8]
 2731 0950 BA325BE1 		ldrh	r3, [fp, #-42]	@ movhi
 2732 0954 033002E0 		and	r3, r2, r3
 2733 0958 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 563:../os_port/os_flag.c ****              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want 
 2734              		.loc 1 563 0
 2735 095c B0215BE1 		ldrh	r2, [fp, #-16]
 2736 0960 BA325BE1 		ldrh	r3, [fp, #-42]
 2737 0964 030052E1 		cmp	r2, r3
 2738 0968 1C00001A 		bne	.L70
 564:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 2739              		.loc 1 564 0
 2740 096c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2741 0970 010053E3 		cmp	r3, #1
 2742 0974 0E00001A 		bne	.L71
 565:../os_port/os_flag.c ****                      pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted  
 2743              		.loc 1 565 0
 2744 0978 28301BE5 		ldr	r3, [fp, #-40]
 2745 097c B830D3E1 		ldrh	r3, [r3, #8]
 2746 0980 0338A0E1 		mov	r3, r3, asl #16
 2747 0984 2328A0E1 		mov	r2, r3, lsr #16
 2748 0988 B0315BE1 		ldrh	r3, [fp, #-16]
 2749 098c 0330E0E1 		mvn	r3, r3
 2750 0990 0338A0E1 		mov	r3, r3, asl #16
 2751 0994 2338A0E1 		mov	r3, r3, lsr #16
 2752 0998 033002E0 		and	r3, r2, r3
 2753 099c 0338A0E1 		mov	r3, r3, asl #16
 2754 09a0 2338A0E1 		mov	r3, r3, lsr #16
 2755 09a4 0338A0E1 		mov	r3, r3, asl #16
 2756 09a8 2328A0E1 		mov	r2, r3, lsr #16
 2757 09ac 28301BE5 		ldr	r3, [fp, #-40]
 2758 09b0 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 2759              	.L71:
 566:../os_port/os_flag.c ****                  }
 567:../os_port/os_flag.c ****                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready           
 2760              		.loc 1 567 0
 2761 09b4 08349FE5 		ldr	r3, .L85+4
 2762 09b8 003093E5 		ldr	r3, [r3, #0]
 2763 09bc B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 2764 09c0 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 568:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller 
 2765              		.loc 1 568 0
 2766              	@ 568 "../os_port/os_flag.c" 1
 2767 09c4 04009DE4 		ldmfd sp!, {r0}
 2768              	@ 0 "" 2
 2769              	@ 568 "../os_port/os_flag.c" 1
 2770 09c8 00F021E1 		msr   cpsr_c, r0
 2771              	@ 0 "" 2
 569:../os_port/os_flag.c ****                  *err                    = OS_NO_ERR;
 2772              		.loc 1 569 0
 2773 09cc 04309BE5 		ldr	r3, [fp, #4]
 2774 09d0 0020A0E3 		mov	r2, #0
 2775 09d4 0020C3E5 		strb	r2, [r3, #0]
 570:../os_port/os_flag.c ****                  return (flags_rdy);
 2776              		.loc 1 570 0
 2777 09d8 B0315BE1 		ldrh	r3, [fp, #-16]
 2778 09dc F30000EA 		b	.L59
 2779              	.L70:
 571:../os_port/os_flag.c ****              } else {                                      /* Block task until events occur or time
 572:../os_port/os_flag.c ****                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2780              		.loc 1 572 0
 2781 09e0 24104BE2 		sub	r1, fp, #36
 2782 09e4 BA225BE1 		ldrh	r2, [fp, #-42]
 2783 09e8 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 2784 09ec BE025BE1 		ldrh	r0, [fp, #-46]
 2785 09f0 00008DE5 		str	r0, [sp, #0]
 2786 09f4 28001BE5 		ldr	r0, [fp, #-40]
 2787 09f8 1E0200EB 		bl	OS_FlagBlock
 573:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 2788              		.loc 1 573 0
 2789              	@ 573 "../os_port/os_flag.c" 1
 2790 09fc 04009DE4 		ldmfd sp!, {r0}
 2791              	@ 0 "" 2
 2792              	@ 573 "../os_port/os_flag.c" 1
 2793 0a00 00F021E1 		msr   cpsr_c, r0
 2794              	@ 0 "" 2
 574:../os_port/os_flag.c ****              }
 575:../os_port/os_flag.c ****              break;
 2795              		.loc 1 575 0
 2796 0a04 960000EA 		b	.L72
 2797              	.L68:
 576:../os_port/os_flag.c **** 
 577:../os_port/os_flag.c ****         case OS_FLAG_WAIT_SET_ANY:
 578:../os_port/os_flag.c ****              flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want        
 2798              		.loc 1 578 0
 2799 0a08 28301BE5 		ldr	r3, [fp, #-40]
 2800 0a0c B820D3E1 		ldrh	r2, [r3, #8]
 2801 0a10 BA325BE1 		ldrh	r3, [fp, #-42]	@ movhi
 2802 0a14 033002E0 		and	r3, r2, r3
 2803 0a18 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 579:../os_port/os_flag.c ****              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                  
 2804              		.loc 1 579 0
 2805 0a1c B0315BE1 		ldrh	r3, [fp, #-16]
 2806 0a20 000053E3 		cmp	r3, #0
 2807 0a24 1C00000A 		beq	.L73
 580:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 2808              		.loc 1 580 0
 2809 0a28 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2810 0a2c 010053E3 		cmp	r3, #1
 2811 0a30 0E00001A 		bne	.L74
 581:../os_port/os_flag.c ****                      pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got     
 2812              		.loc 1 581 0
 2813 0a34 28301BE5 		ldr	r3, [fp, #-40]
 2814 0a38 B830D3E1 		ldrh	r3, [r3, #8]
 2815 0a3c 0338A0E1 		mov	r3, r3, asl #16
 2816 0a40 2328A0E1 		mov	r2, r3, lsr #16
 2817 0a44 B0315BE1 		ldrh	r3, [fp, #-16]
 2818 0a48 0330E0E1 		mvn	r3, r3
 2819 0a4c 0338A0E1 		mov	r3, r3, asl #16
 2820 0a50 2338A0E1 		mov	r3, r3, lsr #16
 2821 0a54 033002E0 		and	r3, r2, r3
 2822 0a58 0338A0E1 		mov	r3, r3, asl #16
 2823 0a5c 2338A0E1 		mov	r3, r3, lsr #16
 2824 0a60 0338A0E1 		mov	r3, r3, asl #16
 2825 0a64 2328A0E1 		mov	r2, r3, lsr #16
 2826 0a68 28301BE5 		ldr	r3, [fp, #-40]
 2827 0a6c B820C3E1 		strh	r2, [r3, #8]	@ movhi
 2828              	.L74:
 582:../os_port/os_flag.c ****                  }
 583:../os_port/os_flag.c ****                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready           
 2829              		.loc 1 583 0
 2830 0a70 4C339FE5 		ldr	r3, .L85+4
 2831 0a74 003093E5 		ldr	r3, [r3, #0]
 2832 0a78 B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 2833 0a7c B822C3E1 		strh	r2, [r3, #40]	@ movhi
 584:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller 
 2834              		.loc 1 584 0
 2835              	@ 584 "../os_port/os_flag.c" 1
 2836 0a80 04009DE4 		ldmfd sp!, {r0}
 2837              	@ 0 "" 2
 2838              	@ 584 "../os_port/os_flag.c" 1
 2839 0a84 00F021E1 		msr   cpsr_c, r0
 2840              	@ 0 "" 2
 585:../os_port/os_flag.c ****                  *err                    = OS_NO_ERR;
 2841              		.loc 1 585 0
 2842 0a88 04309BE5 		ldr	r3, [fp, #4]
 2843 0a8c 0020A0E3 		mov	r2, #0
 2844 0a90 0020C3E5 		strb	r2, [r3, #0]
 586:../os_port/os_flag.c ****                  return (flags_rdy);
 2845              		.loc 1 586 0
 2846 0a94 B0315BE1 		ldrh	r3, [fp, #-16]
 2847 0a98 C40000EA 		b	.L59
 2848              	.L73:
 587:../os_port/os_flag.c ****              } else {                                      /* Block task until events occur or time
 588:../os_port/os_flag.c ****                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2849              		.loc 1 588 0
 2850 0a9c 24104BE2 		sub	r1, fp, #36
 2851 0aa0 BA225BE1 		ldrh	r2, [fp, #-42]
 2852 0aa4 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 2853 0aa8 BE025BE1 		ldrh	r0, [fp, #-46]
 2854 0aac 00008DE5 		str	r0, [sp, #0]
 2855 0ab0 28001BE5 		ldr	r0, [fp, #-40]
 2856 0ab4 EF0100EB 		bl	OS_FlagBlock
 589:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 2857              		.loc 1 589 0
 2858              	@ 589 "../os_port/os_flag.c" 1
 2859 0ab8 04009DE4 		ldmfd sp!, {r0}
 2860              	@ 0 "" 2
 2861              	@ 589 "../os_port/os_flag.c" 1
 2862 0abc 00F021E1 		msr   cpsr_c, r0
 2863              	@ 0 "" 2
 590:../os_port/os_flag.c ****              }
 591:../os_port/os_flag.c ****              break;
 2864              		.loc 1 591 0
 2865 0ac0 670000EA 		b	.L72
 2866              	.L65:
 592:../os_port/os_flag.c **** 
 593:../os_port/os_flag.c **** #if OS_FLAG_WAIT_CLR_EN > 0
 594:../os_port/os_flag.c ****         case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared
 595:../os_port/os_flag.c ****              flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want        
 2867              		.loc 1 595 0
 2868 0ac4 28301BE5 		ldr	r3, [fp, #-40]
 2869 0ac8 B830D3E1 		ldrh	r3, [r3, #8]
 2870 0acc 0338A0E1 		mov	r3, r3, asl #16
 2871 0ad0 2338A0E1 		mov	r3, r3, lsr #16
 2872 0ad4 0330E0E1 		mvn	r3, r3
 2873 0ad8 0338A0E1 		mov	r3, r3, asl #16
 2874 0adc 2328A0E1 		mov	r2, r3, lsr #16
 2875 0ae0 BA325BE1 		ldrh	r3, [fp, #-42]
 2876 0ae4 033002E0 		and	r3, r2, r3
 2877 0ae8 0338A0E1 		mov	r3, r3, asl #16
 2878 0aec 2338A0E1 		mov	r3, r3, lsr #16
 2879 0af0 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 596:../os_port/os_flag.c ****              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want 
 2880              		.loc 1 596 0
 2881 0af4 B0215BE1 		ldrh	r2, [fp, #-16]
 2882 0af8 BA325BE1 		ldrh	r3, [fp, #-42]
 2883 0afc 030052E1 		cmp	r2, r3
 2884 0b00 1500001A 		bne	.L75
 597:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 2885              		.loc 1 597 0
 2886 0b04 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2887 0b08 010053E3 		cmp	r3, #1
 2888 0b0c 0700001A 		bne	.L76
 598:../os_port/os_flag.c ****                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted    
 2889              		.loc 1 598 0
 2890 0b10 28301BE5 		ldr	r3, [fp, #-40]
 2891 0b14 B820D3E1 		ldrh	r2, [r3, #8]
 2892 0b18 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 2893 0b1c 033082E1 		orr	r3, r2, r3
 2894 0b20 0338A0E1 		mov	r3, r3, asl #16
 2895 0b24 2328A0E1 		mov	r2, r3, lsr #16
 2896 0b28 28301BE5 		ldr	r3, [fp, #-40]
 2897 0b2c B820C3E1 		strh	r2, [r3, #8]	@ movhi
 2898              	.L76:
 599:../os_port/os_flag.c ****                  }
 600:../os_port/os_flag.c ****                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready           
 2899              		.loc 1 600 0
 2900 0b30 8C329FE5 		ldr	r3, .L85+4
 2901 0b34 003093E5 		ldr	r3, [r3, #0]
 2902 0b38 B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 2903 0b3c B822C3E1 		strh	r2, [r3, #40]	@ movhi
 601:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller 
 2904              		.loc 1 601 0
 2905              	@ 601 "../os_port/os_flag.c" 1
 2906 0b40 04009DE4 		ldmfd sp!, {r0}
 2907              	@ 0 "" 2
 2908              	@ 601 "../os_port/os_flag.c" 1
 2909 0b44 00F021E1 		msr   cpsr_c, r0
 2910              	@ 0 "" 2
 602:../os_port/os_flag.c ****                  *err                    = OS_NO_ERR;
 2911              		.loc 1 602 0
 2912 0b48 04309BE5 		ldr	r3, [fp, #4]
 2913 0b4c 0020A0E3 		mov	r2, #0
 2914 0b50 0020C3E5 		strb	r2, [r3, #0]
 603:../os_port/os_flag.c ****                  return (flags_rdy);
 2915              		.loc 1 603 0
 2916 0b54 B0315BE1 		ldrh	r3, [fp, #-16]
 2917 0b58 940000EA 		b	.L59
 2918              	.L75:
 604:../os_port/os_flag.c ****              } else {                                      /* Block task until events occur or time
 605:../os_port/os_flag.c ****                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2919              		.loc 1 605 0
 2920 0b5c 24104BE2 		sub	r1, fp, #36
 2921 0b60 BA225BE1 		ldrh	r2, [fp, #-42]
 2922 0b64 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 2923 0b68 BE025BE1 		ldrh	r0, [fp, #-46]
 2924 0b6c 00008DE5 		str	r0, [sp, #0]
 2925 0b70 28001BE5 		ldr	r0, [fp, #-40]
 2926 0b74 BF0100EB 		bl	OS_FlagBlock
 606:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 2927              		.loc 1 606 0
 2928              	@ 606 "../os_port/os_flag.c" 1
 2929 0b78 04009DE4 		ldmfd sp!, {r0}
 2930              	@ 0 "" 2
 2931              	@ 606 "../os_port/os_flag.c" 1
 2932 0b7c 00F021E1 		msr   cpsr_c, r0
 2933              	@ 0 "" 2
 607:../os_port/os_flag.c ****              }
 608:../os_port/os_flag.c ****              break;
 2934              		.loc 1 608 0
 2935 0b80 370000EA 		b	.L72
 2936              	.L66:
 609:../os_port/os_flag.c **** 
 610:../os_port/os_flag.c ****         case OS_FLAG_WAIT_CLR_ANY:
 611:../os_port/os_flag.c ****              flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want        
 2937              		.loc 1 611 0
 2938 0b84 28301BE5 		ldr	r3, [fp, #-40]
 2939 0b88 B830D3E1 		ldrh	r3, [r3, #8]
 2940 0b8c 0338A0E1 		mov	r3, r3, asl #16
 2941 0b90 2338A0E1 		mov	r3, r3, lsr #16
 2942 0b94 0330E0E1 		mvn	r3, r3
 2943 0b98 0338A0E1 		mov	r3, r3, asl #16
 2944 0b9c 2328A0E1 		mov	r2, r3, lsr #16
 2945 0ba0 BA325BE1 		ldrh	r3, [fp, #-42]
 2946 0ba4 033002E0 		and	r3, r2, r3
 2947 0ba8 0338A0E1 		mov	r3, r3, asl #16
 2948 0bac 2338A0E1 		mov	r3, r3, lsr #16
 2949 0bb0 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 612:../os_port/os_flag.c ****              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared              
 2950              		.loc 1 612 0
 2951 0bb4 B0315BE1 		ldrh	r3, [fp, #-16]
 2952 0bb8 000053E3 		cmp	r3, #0
 2953 0bbc 1500000A 		beq	.L77
 613:../os_port/os_flag.c ****                  if (consume == TRUE) {                    /* See if we need to consume the flags  
 2954              		.loc 1 613 0
 2955 0bc0 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2956 0bc4 010053E3 		cmp	r3, #1
 2957 0bc8 0700001A 		bne	.L78
 614:../os_port/os_flag.c ****                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got       
 2958              		.loc 1 614 0
 2959 0bcc 28301BE5 		ldr	r3, [fp, #-40]
 2960 0bd0 B820D3E1 		ldrh	r2, [r3, #8]
 2961 0bd4 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 2962 0bd8 033082E1 		orr	r3, r2, r3
 2963 0bdc 0338A0E1 		mov	r3, r3, asl #16
 2964 0be0 2328A0E1 		mov	r2, r3, lsr #16
 2965 0be4 28301BE5 		ldr	r3, [fp, #-40]
 2966 0be8 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 2967              	.L78:
 615:../os_port/os_flag.c ****                  }
 616:../os_port/os_flag.c ****                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready           
 2968              		.loc 1 616 0
 2969 0bec D0319FE5 		ldr	r3, .L85+4
 2970 0bf0 003093E5 		ldr	r3, [r3, #0]
 2971 0bf4 B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 2972 0bf8 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 617:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller 
 2973              		.loc 1 617 0
 2974              	@ 617 "../os_port/os_flag.c" 1
 2975 0bfc 04009DE4 		ldmfd sp!, {r0}
 2976              	@ 0 "" 2
 2977              	@ 617 "../os_port/os_flag.c" 1
 2978 0c00 00F021E1 		msr   cpsr_c, r0
 2979              	@ 0 "" 2
 618:../os_port/os_flag.c ****                  *err                    = OS_NO_ERR;
 2980              		.loc 1 618 0
 2981 0c04 04309BE5 		ldr	r3, [fp, #4]
 2982 0c08 0020A0E3 		mov	r2, #0
 2983 0c0c 0020C3E5 		strb	r2, [r3, #0]
 619:../os_port/os_flag.c ****                  return (flags_rdy);
 2984              		.loc 1 619 0
 2985 0c10 B0315BE1 		ldrh	r3, [fp, #-16]
 2986 0c14 650000EA 		b	.L59
 2987              	.L77:
 620:../os_port/os_flag.c ****              } else {                                      /* Block task until events occur or time
 621:../os_port/os_flag.c ****                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2988              		.loc 1 621 0
 2989 0c18 24104BE2 		sub	r1, fp, #36
 2990 0c1c BA225BE1 		ldrh	r2, [fp, #-42]
 2991 0c20 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 2992 0c24 BE025BE1 		ldrh	r0, [fp, #-46]
 2993 0c28 00008DE5 		str	r0, [sp, #0]
 2994 0c2c 28001BE5 		ldr	r0, [fp, #-40]
 2995 0c30 900100EB 		bl	OS_FlagBlock
 622:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 2996              		.loc 1 622 0
 2997              	@ 622 "../os_port/os_flag.c" 1
 2998 0c34 04009DE4 		ldmfd sp!, {r0}
 2999              	@ 0 "" 2
 3000              	@ 622 "../os_port/os_flag.c" 1
 3001 0c38 00F021E1 		msr   cpsr_c, r0
 3002              	@ 0 "" 2
 623:../os_port/os_flag.c ****              }
 624:../os_port/os_flag.c ****              break;
 3003              		.loc 1 624 0
 3004 0c3c 080000EA 		b	.L72
 3005              	.L64:
 625:../os_port/os_flag.c **** #endif
 626:../os_port/os_flag.c **** 
 627:../os_port/os_flag.c ****         default:
 628:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();
 3006              		.loc 1 628 0
 3007              	@ 628 "../os_port/os_flag.c" 1
 3008 0c40 04009DE4 		ldmfd sp!, {r0}
 3009              	@ 0 "" 2
 3010              	@ 628 "../os_port/os_flag.c" 1
 3011 0c44 00F021E1 		msr   cpsr_c, r0
 3012              	@ 0 "" 2
 629:../os_port/os_flag.c ****              flags_rdy = (OS_FLAGS)0;
 3013              		.loc 1 629 0
 3014 0c48 0030A0E3 		mov	r3, #0
 3015 0c4c B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 630:../os_port/os_flag.c ****              *err      = OS_FLAG_ERR_WAIT_TYPE;
 3016              		.loc 1 630 0
 3017 0c50 04309BE5 		ldr	r3, [fp, #4]
 3018 0c54 6820E0E3 		mvn	r2, #104
 3019 0c58 0020C3E5 		strb	r2, [r3, #0]
 631:../os_port/os_flag.c ****              return (flags_rdy);
 3020              		.loc 1 631 0
 3021 0c5c B0315BE1 		ldrh	r3, [fp, #-16]
 3022 0c60 520000EA 		b	.L59
 3023              	.L72:
 632:../os_port/os_flag.c ****     }
 633:../os_port/os_flag.c ****     OS_Sched();                                            /* Find next HPT ready to run           
 3024              		.loc 1 633 0
 3025 0c64 FEFFFFEB 		bl	OS_Sched
 634:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 3026              		.loc 1 634 0
 3027              	@ 634 "../os_port/os_flag.c" 1
 3028 0c68 00000FE1 		mrs   r0, cpsr
 3029              	@ 0 "" 2
 3030              	@ 634 "../os_port/os_flag.c" 1
 3031 0c6c 04002DE5 		stmfd sp!, {r0}
 3032              	@ 0 "" 2
 3033              	@ 634 "../os_port/os_flag.c" 1
 3034 0c70 C00080E3 		orr   r0, r0, #0b11000000
 3035              	@ 0 "" 2
 3036              	@ 634 "../os_port/os_flag.c" 1
 3037 0c74 00F021E1 		msr   cpsr_c, r0
 3038              	@ 0 "" 2
 635:../os_port/os_flag.c ****     if (OSTCBCur->OSTCBPendTO == TRUE) {                   /* Have we timed-out?                   
 3039              		.loc 1 635 0
 3040 0c78 44319FE5 		ldr	r3, .L85+4
 3041 0c7c 003093E5 		ldr	r3, [r3, #0]
 3042 0c80 2D30D3E5 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
 3043 0c84 010053E3 		cmp	r3, #1
 3044 0c88 1300001A 		bne	.L79
 636:../os_port/os_flag.c ****         OSTCBCur->OSTCBPendTO = FALSE;
 3045              		.loc 1 636 0
 3046 0c8c 30319FE5 		ldr	r3, .L85+4
 3047 0c90 003093E5 		ldr	r3, [r3, #0]
 3048 0c94 0020A0E3 		mov	r2, #0
 3049 0c98 2D20C3E5 		strb	r2, [r3, #45]
 637:../os_port/os_flag.c ****         OS_FlagUnlink(&node);
 3050              		.loc 1 637 0
 3051 0c9c 24304BE2 		sub	r3, fp, #36
 3052 0ca0 0300A0E1 		mov	r0, r3
 3053 0ca4 FEFFFFEB 		bl	OS_FlagUnlink
 638:../os_port/os_flag.c ****         OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run          
 3054              		.loc 1 638 0
 3055 0ca8 14319FE5 		ldr	r3, .L85+4
 3056 0cac 003093E5 		ldr	r3, [r3, #0]
 3057 0cb0 0020A0E3 		mov	r2, #0
 3058 0cb4 2C20C3E5 		strb	r2, [r3, #44]
 639:../os_port/os_flag.c ****         OS_EXIT_CRITICAL();
 3059              		.loc 1 639 0
 3060              	@ 639 "../os_port/os_flag.c" 1
 3061 0cb8 04009DE4 		ldmfd sp!, {r0}
 3062              	@ 0 "" 2
 3063              	@ 639 "../os_port/os_flag.c" 1
 3064 0cbc 00F021E1 		msr   cpsr_c, r0
 3065              	@ 0 "" 2
 640:../os_port/os_flag.c ****         flags_rdy             = (OS_FLAGS)0;
 3066              		.loc 1 640 0
 3067 0cc0 0030A0E3 		mov	r3, #0
 3068 0cc4 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 641:../os_port/os_flag.c ****         *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting   
 3069              		.loc 1 641 0
 3070 0cc8 04309BE5 		ldr	r3, [fp, #4]
 3071 0ccc 0A20A0E3 		mov	r2, #10
 3072 0cd0 0020C3E5 		strb	r2, [r3, #0]
 642:../os_port/os_flag.c ****         return (flags_rdy);
 3073              		.loc 1 642 0
 3074 0cd4 B0315BE1 		ldrh	r3, [fp, #-16]
 3075 0cd8 340000EA 		b	.L59
 3076              	.L79:
 643:../os_port/os_flag.c ****     } 
 644:../os_port/os_flag.c ****     flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 3077              		.loc 1 644 0
 3078 0cdc E0309FE5 		ldr	r3, .L85+4
 3079 0ce0 003093E5 		ldr	r3, [r3, #0]
 3080 0ce4 B832D3E1 		ldrh	r3, [r3, #40]	@ movhi
 3081 0ce8 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 645:../os_port/os_flag.c ****     if (consume == TRUE) {                                 /* See if we need to consume the flags  
 3082              		.loc 1 645 0
 3083 0cec 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3084 0cf0 010053E3 		cmp	r3, #1
 3085 0cf4 2700001A 		bne	.L80
 646:../os_port/os_flag.c ****         switch (wait_type) {
 3086              		.loc 1 646 0
 3087 0cf8 2B305BE5 		ldrb	r3, [fp, #-43]	@ zero_extendqisi2
 3088 0cfc 030053E3 		cmp	r3, #3
 3089 0d00 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3090 0d04 1C0000EA 		b	.L81
 3091              	.L84:
 3092 0d08 580D0000 		.word	.L82
 3093 0d0c 580D0000 		.word	.L82
 3094 0d10 180D0000 		.word	.L83
 3095 0d14 180D0000 		.word	.L83
 3096              	.L83:
 647:../os_port/os_flag.c ****             case OS_FLAG_WAIT_SET_ALL:
 648:../os_port/os_flag.c ****             case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got          
 649:../os_port/os_flag.c ****                  pgrp->OSFlagFlags &= ~flags_rdy;
 3097              		.loc 1 649 0
 3098 0d18 28301BE5 		ldr	r3, [fp, #-40]
 3099 0d1c B830D3E1 		ldrh	r3, [r3, #8]
 3100 0d20 0338A0E1 		mov	r3, r3, asl #16
 3101 0d24 2328A0E1 		mov	r2, r3, lsr #16
 3102 0d28 B0315BE1 		ldrh	r3, [fp, #-16]
 3103 0d2c 0330E0E1 		mvn	r3, r3
 3104 0d30 0338A0E1 		mov	r3, r3, asl #16
 3105 0d34 2338A0E1 		mov	r3, r3, lsr #16
 3106 0d38 033002E0 		and	r3, r2, r3
 3107 0d3c 0338A0E1 		mov	r3, r3, asl #16
 3108 0d40 2338A0E1 		mov	r3, r3, lsr #16
 3109 0d44 0338A0E1 		mov	r3, r3, asl #16
 3110 0d48 2328A0E1 		mov	r2, r3, lsr #16
 3111 0d4c 28301BE5 		ldr	r3, [fp, #-40]
 3112 0d50 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 650:../os_port/os_flag.c ****                  break;
 3113              		.loc 1 650 0
 3114 0d54 0F0000EA 		b	.L80
 3115              	.L82:
 651:../os_port/os_flag.c **** 
 652:../os_port/os_flag.c **** #if OS_FLAG_WAIT_CLR_EN > 0
 653:../os_port/os_flag.c ****             case OS_FLAG_WAIT_CLR_ALL:
 654:../os_port/os_flag.c ****             case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got          
 655:../os_port/os_flag.c ****                  pgrp->OSFlagFlags |=  flags_rdy;
 3116              		.loc 1 655 0
 3117 0d58 28301BE5 		ldr	r3, [fp, #-40]
 3118 0d5c B820D3E1 		ldrh	r2, [r3, #8]
 3119 0d60 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 3120 0d64 033082E1 		orr	r3, r2, r3
 3121 0d68 0338A0E1 		mov	r3, r3, asl #16
 3122 0d6c 2328A0E1 		mov	r2, r3, lsr #16
 3123 0d70 28301BE5 		ldr	r3, [fp, #-40]
 3124 0d74 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 656:../os_port/os_flag.c ****                  break;
 3125              		.loc 1 656 0
 3126 0d78 060000EA 		b	.L80
 3127              	.L81:
 657:../os_port/os_flag.c **** #endif
 658:../os_port/os_flag.c ****             default:
 659:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 3128              		.loc 1 659 0
 3129              	@ 659 "../os_port/os_flag.c" 1
 3130 0d7c 04009DE4 		ldmfd sp!, {r0}
 3131              	@ 0 "" 2
 3132              	@ 659 "../os_port/os_flag.c" 1
 3133 0d80 00F021E1 		msr   cpsr_c, r0
 3134              	@ 0 "" 2
 660:../os_port/os_flag.c ****                  *err = OS_FLAG_ERR_WAIT_TYPE;
 3135              		.loc 1 660 0
 3136 0d84 04309BE5 		ldr	r3, [fp, #4]
 3137 0d88 6820E0E3 		mvn	r2, #104
 3138 0d8c 0020C3E5 		strb	r2, [r3, #0]
 661:../os_port/os_flag.c ****                  return ((OS_FLAGS)0);
 3139              		.loc 1 661 0
 3140 0d90 0030A0E3 		mov	r3, #0
 3141 0d94 050000EA 		b	.L59
 3142              	.L80:
 662:../os_port/os_flag.c ****         }
 663:../os_port/os_flag.c ****     }
 664:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 3143              		.loc 1 664 0
 3144              	@ 664 "../os_port/os_flag.c" 1
 3145 0d98 04009DE4 		ldmfd sp!, {r0}
 3146              	@ 0 "" 2
 3147              	@ 664 "../os_port/os_flag.c" 1
 3148 0d9c 00F021E1 		msr   cpsr_c, r0
 3149              	@ 0 "" 2
 665:../os_port/os_flag.c ****     *err = OS_NO_ERR;                                      /* Event(s) must have occurred          
 3150              		.loc 1 665 0
 3151 0da0 04309BE5 		ldr	r3, [fp, #4]
 3152 0da4 0020A0E3 		mov	r2, #0
 3153 0da8 0020C3E5 		strb	r2, [r3, #0]
 666:../os_port/os_flag.c ****     return (flags_rdy);
 3154              		.loc 1 666 0
 3155 0dac B0315BE1 		ldrh	r3, [fp, #-16]
 3156              	.L59:
 667:../os_port/os_flag.c **** }
 3157              		.loc 1 667 0
 3158 0db0 0300A0E1 		mov	r0, r3
 3159 0db4 0CD04BE2 		sub	sp, fp, #12
 3160 0db8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3161 0dbc 1EFF2FE1 		bx	lr
 3162              	.L86:
 3163              		.align	2
 3164              	.L85:
 3165 0dc0 00000000 		.word	OSIntNesting
 3166 0dc4 00000000 		.word	OSTCBCur
 3167              		.cfi_endproc
 3168              	.LFE5:
 3170              		.align	2
 3171              		.global	OSFlagPendGetFlagsRdy
 3173              	OSFlagPendGetFlagsRdy:
 3174              	.LFB6:
 668:../os_port/os_flag.c **** /*$PAGE*/
 669:../os_port/os_flag.c **** /*
 670:../os_port/os_flag.c **** ***************************************************************************************************
 671:../os_port/os_flag.c **** *                               GET FLAGS WHO CAUSED TASK TO BECOME READY
 672:../os_port/os_flag.c **** *
 673:../os_port/os_flag.c **** * Description: This function is called to obtain the flags that caused the task to become ready to 
 674:../os_port/os_flag.c **** *              In other words, this function allows you to tell "Who done it!".
 675:../os_port/os_flag.c **** *
 676:../os_port/os_flag.c **** * Arguments  : None
 677:../os_port/os_flag.c **** *
 678:../os_port/os_flag.c **** * Returns    : The flags that caused the task to be ready.
 679:../os_port/os_flag.c **** *
 680:../os_port/os_flag.c **** * Called from: Task ONLY
 681:../os_port/os_flag.c **** ***************************************************************************************************
 682:../os_port/os_flag.c **** */
 683:../os_port/os_flag.c **** 
 684:../os_port/os_flag.c **** OS_FLAGS  OSFlagPendGetFlagsRdy (void)
 685:../os_port/os_flag.c **** {
 3175              		.loc 1 685 0
 3176              		.cfi_startproc
 3177              		@ Function supports interworking.
 3178              		@ args = 0, pretend = 0, frame = 8
 3179              		@ frame_needed = 1, uses_anonymous_args = 0
 3180 0dc8 0DC0A0E1 		mov	ip, sp
 3181              	.LCFI12:
 3182              		.cfi_def_cfa_register 12
 3183 0dcc 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3184 0dd0 04B04CE2 		sub	fp, ip, #4
 3185              		.cfi_offset 14, -8
 3186              		.cfi_offset 13, -12
 3187              		.cfi_offset 11, -16
 3188              	.LCFI13:
 3189              		.cfi_def_cfa 11, 4
 3190 0dd4 08D04DE2 		sub	sp, sp, #8
 686:../os_port/os_flag.c ****     OS_FLAGS      flags;
 687:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status regis
 688:../os_port/os_flag.c ****     OS_CPU_SR     cpu_sr;
 689:../os_port/os_flag.c **** 
 690:../os_port/os_flag.c **** 
 691:../os_port/os_flag.c **** 
 692:../os_port/os_flag.c ****     cpu_sr = 0;                                            /* Prevent compiler warning             
 693:../os_port/os_flag.c **** #endif    
 694:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 3191              		.loc 1 694 0
 3192              	@ 694 "../os_port/os_flag.c" 1
 3193 0dd8 00000FE1 		mrs   r0, cpsr
 3194              	@ 0 "" 2
 3195              	@ 694 "../os_port/os_flag.c" 1
 3196 0ddc 04002DE5 		stmfd sp!, {r0}
 3197              	@ 0 "" 2
 3198              	@ 694 "../os_port/os_flag.c" 1
 3199 0de0 C00080E3 		orr   r0, r0, #0b11000000
 3200              	@ 0 "" 2
 3201              	@ 694 "../os_port/os_flag.c" 1
 3202 0de4 00F021E1 		msr   cpsr_c, r0
 3203              	@ 0 "" 2
 695:../os_port/os_flag.c ****     flags = OSTCBCur->OSTCBFlagsRdy;
 3204              		.loc 1 695 0
 3205 0de8 24309FE5 		ldr	r3, .L88
 3206 0dec 003093E5 		ldr	r3, [r3, #0]
 3207 0df0 B832D3E1 		ldrh	r3, [r3, #40]	@ movhi
 3208 0df4 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 696:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 3209              		.loc 1 696 0
 3210              	@ 696 "../os_port/os_flag.c" 1
 3211 0df8 04009DE4 		ldmfd sp!, {r0}
 3212              	@ 0 "" 2
 3213              	@ 696 "../os_port/os_flag.c" 1
 3214 0dfc 00F021E1 		msr   cpsr_c, r0
 3215              	@ 0 "" 2
 697:../os_port/os_flag.c ****     return (flags);
 3216              		.loc 1 697 0
 3217 0e00 BE305BE1 		ldrh	r3, [fp, #-14]
 698:../os_port/os_flag.c **** }
 3218              		.loc 1 698 0
 3219 0e04 0300A0E1 		mov	r0, r3
 3220 0e08 0CD04BE2 		sub	sp, fp, #12
 3221 0e0c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3222 0e10 1EFF2FE1 		bx	lr
 3223              	.L89:
 3224              		.align	2
 3225              	.L88:
 3226 0e14 00000000 		.word	OSTCBCur
 3227              		.cfi_endproc
 3228              	.LFE6:
 3230              		.align	2
 3231              		.global	OSFlagPost
 3233              	OSFlagPost:
 3234              	.LFB7:
 699:../os_port/os_flag.c **** 
 700:../os_port/os_flag.c **** /*$PAGE*/
 701:../os_port/os_flag.c **** /*
 702:../os_port/os_flag.c **** ***************************************************************************************************
 703:../os_port/os_flag.c **** *                                         POST EVENT FLAG BIT(S)
 704:../os_port/os_flag.c **** *
 705:../os_port/os_flag.c **** * Description: This function is called to set or clear some bits in an event flag group.  The bits 
 706:../os_port/os_flag.c **** *              set or clear are specified by a 'bit mask'.
 707:../os_port/os_flag.c **** *
 708:../os_port/os_flag.c **** * Arguments  : pgrp          is a pointer to the desired event flag group.
 709:../os_port/os_flag.c **** *
 710:../os_port/os_flag.c **** *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' w
 711:../os_port/os_flag.c **** *                            set the corresponding bit in the event flag group.  e.g. to set bits 0
 712:../os_port/os_flag.c **** *                            and 5 you would set 'flags' to:
 713:../os_port/os_flag.c **** *
 714:../os_port/os_flag.c **** *                                0x31     (note, bit 0 is least significant bit)
 715:../os_port/os_flag.c **** *
 716:../os_port/os_flag.c **** *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' w
 717:../os_port/os_flag.c **** *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bi
 718:../os_port/os_flag.c **** *                            4 and 5 you would specify 'flags' as:
 719:../os_port/os_flag.c **** *
 720:../os_port/os_flag.c **** *                                0x31     (note, bit 0 is least significant bit)
 721:../os_port/os_flag.c **** *
 722:../os_port/os_flag.c **** *              opt           indicates whether the flags will be:
 723:../os_port/os_flag.c **** *                                set     (OS_FLAG_SET) or
 724:../os_port/os_flag.c **** *                                cleared (OS_FLAG_CLR)
 725:../os_port/os_flag.c **** *
 726:../os_port/os_flag.c **** *              err           is a pointer to an error code and can be:
 727:../os_port/os_flag.c **** *                            OS_NO_ERR              The call was successfull
 728:../os_port/os_flag.c **** *                            OS_FLAG_INVALID_PGRP   You passed a NULL pointer
 729:../os_port/os_flag.c **** *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
 730:../os_port/os_flag.c **** *                            OS_FLAG_INVALID_OPT    You specified an invalid option
 731:../os_port/os_flag.c **** *
 732:../os_port/os_flag.c **** * Returns    : the new value of the event flags bits that are still set.
 733:../os_port/os_flag.c **** *
 734:../os_port/os_flag.c **** * Called From: Task or ISR
 735:../os_port/os_flag.c **** *
 736:../os_port/os_flag.c **** * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the
 737:../os_port/os_flag.c **** *                 flag group.
 738:../os_port/os_flag.c **** *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting
 739:../os_port/os_flag.c **** *                 the event flag group.
 740:../os_port/os_flag.c **** ***************************************************************************************************
 741:../os_port/os_flag.c **** */
 742:../os_port/os_flag.c **** OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
 743:../os_port/os_flag.c **** {
 3235              		.loc 1 743 0
 3236              		.cfi_startproc
 3237              		@ Function supports interworking.
 3238              		@ args = 0, pretend = 0, frame = 32
 3239              		@ frame_needed = 1, uses_anonymous_args = 0
 3240 0e18 0DC0A0E1 		mov	ip, sp
 3241              	.LCFI14:
 3242              		.cfi_def_cfa_register 12
 3243 0e1c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3244 0e20 04B04CE2 		sub	fp, ip, #4
 3245              		.cfi_offset 14, -8
 3246              		.cfi_offset 13, -12
 3247              		.cfi_offset 11, -16
 3248              	.LCFI15:
 3249              		.cfi_def_cfa 11, 4
 3250 0e24 20D04DE2 		sub	sp, sp, #32
 3251 0e28 20000BE5 		str	r0, [fp, #-32]
 3252 0e2c 28300BE5 		str	r3, [fp, #-40]
 3253 0e30 B2124BE1 		strh	r1, [fp, #-34]	@ movhi
 3254 0e34 0230A0E1 		mov	r3, r2
 3255 0e38 23304BE5 		strb	r3, [fp, #-35]
 744:../os_port/os_flag.c ****     OS_FLAG_NODE *pnode;
 745:../os_port/os_flag.c ****     BOOLEAN       sched;
 746:../os_port/os_flag.c ****     OS_FLAGS      flags_cur;
 747:../os_port/os_flag.c ****     OS_FLAGS      flags_rdy;
 748:../os_port/os_flag.c **** 	BOOLEAN       rdy;
 749:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register   
 750:../os_port/os_flag.c ****     OS_CPU_SR     cpu_sr;
 751:../os_port/os_flag.c **** 
 752:../os_port/os_flag.c **** 
 753:../os_port/os_flag.c **** 
 754:../os_port/os_flag.c ****     cpu_sr = 0;                                      /* Prevent compiler warning                   
 755:../os_port/os_flag.c **** #endif    
 756:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
 757:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                            
 3256              		.loc 1 757 0
 3257 0e3c 20301BE5 		ldr	r3, [fp, #-32]
 3258 0e40 000053E3 		cmp	r3, #0
 3259 0e44 0400001A 		bne	.L91
 758:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 3260              		.loc 1 758 0
 3261 0e48 28301BE5 		ldr	r3, [fp, #-40]
 3262 0e4c 6920E0E3 		mvn	r2, #105
 3263 0e50 0020C3E5 		strb	r2, [r3, #0]
 759:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 3264              		.loc 1 759 0
 3265 0e54 0030A0E3 		mov	r3, #0
 3266 0e58 DA0000EA 		b	.L92
 3267              	.L91:
 760:../os_port/os_flag.c ****     }
 761:../os_port/os_flag.c **** #endif
 762:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag 
 3268              		.loc 1 762 0
 3269 0e5c 20301BE5 		ldr	r3, [fp, #-32]
 3270 0e60 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3271 0e64 050053E3 		cmp	r3, #5
 3272 0e68 0400000A 		beq	.L93
 763:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 3273              		.loc 1 763 0
 3274 0e6c 28301BE5 		ldr	r3, [fp, #-40]
 3275 0e70 0120A0E3 		mov	r2, #1
 3276 0e74 0020C3E5 		strb	r2, [r3, #0]
 764:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 3277              		.loc 1 764 0
 3278 0e78 0030A0E3 		mov	r3, #0
 3279 0e7c D10000EA 		b	.L92
 3280              	.L93:
 765:../os_port/os_flag.c ****     }
 766:../os_port/os_flag.c **** /*$PAGE*/
 767:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 3281              		.loc 1 767 0
 3282              	@ 767 "../os_port/os_flag.c" 1
 3283 0e80 00000FE1 		mrs   r0, cpsr
 3284              	@ 0 "" 2
 3285              	@ 767 "../os_port/os_flag.c" 1
 3286 0e84 04002DE5 		stmfd sp!, {r0}
 3287              	@ 0 "" 2
 3288              	@ 767 "../os_port/os_flag.c" 1
 3289 0e88 C00080E3 		orr   r0, r0, #0b11000000
 3290              	@ 0 "" 2
 3291              	@ 767 "../os_port/os_flag.c" 1
 3292 0e8c 00F021E1 		msr   cpsr_c, r0
 3293              	@ 0 "" 2
 768:../os_port/os_flag.c ****     switch (opt) {
 3294              		.loc 1 768 0
 3295 0e90 23305BE5 		ldrb	r3, [fp, #-35]	@ zero_extendqisi2
 3296 0e94 000053E3 		cmp	r3, #0
 3297 0e98 0200000A 		beq	.L95
 3298 0e9c 010053E3 		cmp	r3, #1
 3299 0ea0 1000000A 		beq	.L96
 3300 0ea4 180000EA 		b	.L112
 3301              	.L95:
 769:../os_port/os_flag.c ****         case OS_FLAG_CLR:
 770:../os_port/os_flag.c ****              pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group     
 3302              		.loc 1 770 0
 3303 0ea8 20301BE5 		ldr	r3, [fp, #-32]
 3304 0eac B830D3E1 		ldrh	r3, [r3, #8]
 3305 0eb0 0338A0E1 		mov	r3, r3, asl #16
 3306 0eb4 2328A0E1 		mov	r2, r3, lsr #16
 3307 0eb8 B2325BE1 		ldrh	r3, [fp, #-34]
 3308 0ebc 0330E0E1 		mvn	r3, r3
 3309 0ec0 0338A0E1 		mov	r3, r3, asl #16
 3310 0ec4 2338A0E1 		mov	r3, r3, lsr #16
 3311 0ec8 033002E0 		and	r3, r2, r3
 3312 0ecc 0338A0E1 		mov	r3, r3, asl #16
 3313 0ed0 2338A0E1 		mov	r3, r3, lsr #16
 3314 0ed4 0338A0E1 		mov	r3, r3, asl #16
 3315 0ed8 2328A0E1 		mov	r2, r3, lsr #16
 3316 0edc 20301BE5 		ldr	r3, [fp, #-32]
 3317 0ee0 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 771:../os_port/os_flag.c ****              break;
 3318              		.loc 1 771 0
 3319 0ee4 0F0000EA 		b	.L97
 3320              	.L96:
 772:../os_port/os_flag.c **** 
 773:../os_port/os_flag.c ****         case OS_FLAG_SET:
 774:../os_port/os_flag.c ****              pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group     
 3321              		.loc 1 774 0
 3322 0ee8 20301BE5 		ldr	r3, [fp, #-32]
 3323 0eec B820D3E1 		ldrh	r2, [r3, #8]
 3324 0ef0 B2325BE1 		ldrh	r3, [fp, #-34]	@ movhi
 3325 0ef4 033082E1 		orr	r3, r2, r3
 3326 0ef8 0338A0E1 		mov	r3, r3, asl #16
 3327 0efc 2328A0E1 		mov	r2, r3, lsr #16
 3328 0f00 20301BE5 		ldr	r3, [fp, #-32]
 3329 0f04 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 775:../os_port/os_flag.c ****              break;
 3330              		.loc 1 775 0
 3331 0f08 060000EA 		b	.L97
 3332              	.L112:
 776:../os_port/os_flag.c **** 
 777:../os_port/os_flag.c ****         default:
 778:../os_port/os_flag.c ****              OS_EXIT_CRITICAL();                     /* INVALID option                             
 3333              		.loc 1 778 0
 3334              	@ 778 "../os_port/os_flag.c" 1
 3335 0f0c 04009DE4 		ldmfd sp!, {r0}
 3336              	@ 0 "" 2
 3337              	@ 778 "../os_port/os_flag.c" 1
 3338 0f10 00F021E1 		msr   cpsr_c, r0
 3339              	@ 0 "" 2
 779:../os_port/os_flag.c ****              *err = OS_FLAG_INVALID_OPT;
 3340              		.loc 1 779 0
 3341 0f14 28301BE5 		ldr	r3, [fp, #-40]
 3342 0f18 6620E0E3 		mvn	r2, #102
 3343 0f1c 0020C3E5 		strb	r2, [r3, #0]
 780:../os_port/os_flag.c ****              return ((OS_FLAGS)0);
 3344              		.loc 1 780 0
 3345 0f20 0030A0E3 		mov	r3, #0
 3346 0f24 A70000EA 		b	.L92
 3347              	.L97:
 781:../os_port/os_flag.c ****     }
 782:../os_port/os_flag.c ****     sched = FALSE;                                   /* Indicate that we don't need rescheduling   
 3348              		.loc 1 782 0
 3349 0f28 0030A0E3 		mov	r3, #0
 3350 0f2c 11304BE5 		strb	r3, [fp, #-17]
 783:../os_port/os_flag.c ****     pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3351              		.loc 1 783 0
 3352 0f30 20301BE5 		ldr	r3, [fp, #-32]
 3353 0f34 043093E5 		ldr	r3, [r3, #4]
 3354 0f38 10300BE5 		str	r3, [fp, #-16]
 784:../os_port/os_flag.c ****     while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(
 3355              		.loc 1 784 0
 3356 0f3c 8B0000EA 		b	.L98
 3357              	.L110:
 785:../os_port/os_flag.c ****         switch (pnode->OSFlagNodeWaitType) {
 3358              		.loc 1 785 0
 3359 0f40 10301BE5 		ldr	r3, [fp, #-16]
 3360 0f44 1230D3E5 		ldrb	r3, [r3, #18]	@ zero_extendqisi2
 3361 0f48 030053E3 		cmp	r3, #3
 3362 0f4c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3363 0f50 6D0000EA 		b	.L99
 3364              	.L104:
 3365 0f54 14100000 		.word	.L100
 3366 0f58 94100000 		.word	.L101
 3367 0f5c 640F0000 		.word	.L102
 3368 0f60 C00F0000 		.word	.L103
 3369              	.L102:
 786:../os_port/os_flag.c ****             case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current n
 787:../os_port/os_flag.c ****                  flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 3370              		.loc 1 787 0
 3371 0f64 20301BE5 		ldr	r3, [fp, #-32]
 3372 0f68 B820D3E1 		ldrh	r2, [r3, #8]
 3373 0f6c 10301BE5 		ldr	r3, [fp, #-16]
 3374 0f70 B031D3E1 		ldrh	r3, [r3, #16]
 3375 0f74 033002E0 		and	r3, r2, r3
 3376 0f78 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 788:../os_port/os_flag.c ****                  if (flags_rdy == pnode->OSFlagNodeFlags) {
 3377              		.loc 1 788 0
 3378 0f7c 10301BE5 		ldr	r3, [fp, #-16]
 3379 0f80 B031D3E1 		ldrh	r3, [r3, #16]
 3380 0f84 B4215BE1 		ldrh	r2, [fp, #-20]
 3381 0f88 030052E1 		cmp	r2, r3
 3382 0f8c 6500001A 		bne	.L113
 789:../os_port/os_flag.c **** 				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3383              		.loc 1 789 0
 3384 0f90 B4315BE1 		ldrh	r3, [fp, #-20]
 3385 0f94 10001BE5 		ldr	r0, [fp, #-16]
 3386 0f98 0310A0E1 		mov	r1, r3
 3387 0f9c 5E0100EB 		bl	OS_FlagTaskRdy
 3388 0fa0 0030A0E1 		mov	r3, r0
 3389 0fa4 15304BE5 		strb	r3, [fp, #-21]
 790:../os_port/os_flag.c ****                      if (rdy == TRUE) {                     
 3390              		.loc 1 790 0
 3391 0fa8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3392 0fac 010053E3 		cmp	r3, #1
 3393 0fb0 5E00001A 		bne	.L114
 791:../os_port/os_flag.c ****                          sched = TRUE;                        /* When done we will reschedule      
 3394              		.loc 1 791 0
 3395 0fb4 0130A0E3 		mov	r3, #1
 3396 0fb8 11304BE5 		strb	r3, [fp, #-17]
 792:../os_port/os_flag.c ****                      }
 793:../os_port/os_flag.c ****                  }
 794:../os_port/os_flag.c ****                  break;
 3397              		.loc 1 794 0
 3398 0fbc 680000EA 		b	.L106
 3399              	.L103:
 795:../os_port/os_flag.c **** 
 796:../os_port/os_flag.c ****             case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                        
 797:../os_port/os_flag.c ****                  flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 3400              		.loc 1 797 0
 3401 0fc0 20301BE5 		ldr	r3, [fp, #-32]
 3402 0fc4 B820D3E1 		ldrh	r2, [r3, #8]
 3403 0fc8 10301BE5 		ldr	r3, [fp, #-16]
 3404 0fcc B031D3E1 		ldrh	r3, [r3, #16]
 3405 0fd0 033002E0 		and	r3, r2, r3
 3406 0fd4 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 798:../os_port/os_flag.c ****                  if (flags_rdy != (OS_FLAGS)0) {
 3407              		.loc 1 798 0
 3408 0fd8 B4315BE1 		ldrh	r3, [fp, #-20]
 3409 0fdc 000053E3 		cmp	r3, #0
 3410 0fe0 5400000A 		beq	.L115
 799:../os_port/os_flag.c **** 				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3411              		.loc 1 799 0
 3412 0fe4 B4315BE1 		ldrh	r3, [fp, #-20]
 3413 0fe8 10001BE5 		ldr	r0, [fp, #-16]
 3414 0fec 0310A0E1 		mov	r1, r3
 3415 0ff0 490100EB 		bl	OS_FlagTaskRdy
 3416 0ff4 0030A0E1 		mov	r3, r0
 3417 0ff8 15304BE5 		strb	r3, [fp, #-21]
 800:../os_port/os_flag.c ****                      if (rdy == TRUE) {                      
 3418              		.loc 1 800 0
 3419 0ffc 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3420 1000 010053E3 		cmp	r3, #1
 3421 1004 4D00001A 		bne	.L116
 801:../os_port/os_flag.c ****                          sched = TRUE;                        /* When done we will reschedule      
 3422              		.loc 1 801 0
 3423 1008 0130A0E3 		mov	r3, #1
 3424 100c 11304BE5 		strb	r3, [fp, #-17]
 802:../os_port/os_flag.c ****                      }
 803:../os_port/os_flag.c ****                  }
 804:../os_port/os_flag.c ****                  break;
 3425              		.loc 1 804 0
 3426 1010 530000EA 		b	.L106
 3427              	.L100:
 805:../os_port/os_flag.c **** 
 806:../os_port/os_flag.c **** #if OS_FLAG_WAIT_CLR_EN > 0
 807:../os_port/os_flag.c ****             case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current n
 808:../os_port/os_flag.c ****                  flags_rdy = ~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 3428              		.loc 1 808 0
 3429 1014 20301BE5 		ldr	r3, [fp, #-32]
 3430 1018 B830D3E1 		ldrh	r3, [r3, #8]
 3431 101c 0338A0E1 		mov	r3, r3, asl #16
 3432 1020 2338A0E1 		mov	r3, r3, lsr #16
 3433 1024 0330E0E1 		mvn	r3, r3
 3434 1028 0338A0E1 		mov	r3, r3, asl #16
 3435 102c 2328A0E1 		mov	r2, r3, lsr #16
 3436 1030 10301BE5 		ldr	r3, [fp, #-16]
 3437 1034 B031D3E1 		ldrh	r3, [r3, #16]
 3438 1038 0338A0E1 		mov	r3, r3, asl #16
 3439 103c 2338A0E1 		mov	r3, r3, lsr #16
 3440 1040 033002E0 		and	r3, r2, r3
 3441 1044 0338A0E1 		mov	r3, r3, asl #16
 3442 1048 2338A0E1 		mov	r3, r3, lsr #16
 3443 104c B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 809:../os_port/os_flag.c ****                  if (flags_rdy == pnode->OSFlagNodeFlags) {
 3444              		.loc 1 809 0
 3445 1050 10301BE5 		ldr	r3, [fp, #-16]
 3446 1054 B031D3E1 		ldrh	r3, [r3, #16]
 3447 1058 B4215BE1 		ldrh	r2, [fp, #-20]
 3448 105c 030052E1 		cmp	r2, r3
 3449 1060 3800001A 		bne	.L117
 810:../os_port/os_flag.c **** 				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3450              		.loc 1 810 0
 3451 1064 B4315BE1 		ldrh	r3, [fp, #-20]
 3452 1068 10001BE5 		ldr	r0, [fp, #-16]
 3453 106c 0310A0E1 		mov	r1, r3
 3454 1070 290100EB 		bl	OS_FlagTaskRdy
 3455 1074 0030A0E1 		mov	r3, r0
 3456 1078 15304BE5 		strb	r3, [fp, #-21]
 811:../os_port/os_flag.c ****                      if (rdy == TRUE) {                       
 3457              		.loc 1 811 0
 3458 107c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3459 1080 010053E3 		cmp	r3, #1
 3460 1084 3100001A 		bne	.L118
 812:../os_port/os_flag.c ****                          sched = TRUE;                        /* When done we will reschedule      
 3461              		.loc 1 812 0
 3462 1088 0130A0E3 		mov	r3, #1
 3463 108c 11304BE5 		strb	r3, [fp, #-17]
 813:../os_port/os_flag.c ****                      }
 814:../os_port/os_flag.c ****                  }
 815:../os_port/os_flag.c ****                  break;
 3464              		.loc 1 815 0
 3465 1090 330000EA 		b	.L106
 3466              	.L101:
 816:../os_port/os_flag.c **** 
 817:../os_port/os_flag.c ****             case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                        
 818:../os_port/os_flag.c ****                  flags_rdy = ~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 3467              		.loc 1 818 0
 3468 1094 20301BE5 		ldr	r3, [fp, #-32]
 3469 1098 B830D3E1 		ldrh	r3, [r3, #8]
 3470 109c 0338A0E1 		mov	r3, r3, asl #16
 3471 10a0 2338A0E1 		mov	r3, r3, lsr #16
 3472 10a4 0330E0E1 		mvn	r3, r3
 3473 10a8 0338A0E1 		mov	r3, r3, asl #16
 3474 10ac 2328A0E1 		mov	r2, r3, lsr #16
 3475 10b0 10301BE5 		ldr	r3, [fp, #-16]
 3476 10b4 B031D3E1 		ldrh	r3, [r3, #16]
 3477 10b8 0338A0E1 		mov	r3, r3, asl #16
 3478 10bc 2338A0E1 		mov	r3, r3, lsr #16
 3479 10c0 033002E0 		and	r3, r2, r3
 3480 10c4 0338A0E1 		mov	r3, r3, asl #16
 3481 10c8 2338A0E1 		mov	r3, r3, lsr #16
 3482 10cc B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 819:../os_port/os_flag.c ****                  if (flags_rdy != (OS_FLAGS)0) {
 3483              		.loc 1 819 0
 3484 10d0 B4315BE1 		ldrh	r3, [fp, #-20]
 3485 10d4 000053E3 		cmp	r3, #0
 3486 10d8 1E00000A 		beq	.L119
 820:../os_port/os_flag.c **** 				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3487              		.loc 1 820 0
 3488 10dc B4315BE1 		ldrh	r3, [fp, #-20]
 3489 10e0 10001BE5 		ldr	r0, [fp, #-16]
 3490 10e4 0310A0E1 		mov	r1, r3
 3491 10e8 0B0100EB 		bl	OS_FlagTaskRdy
 3492 10ec 0030A0E1 		mov	r3, r0
 3493 10f0 15304BE5 		strb	r3, [fp, #-21]
 821:../os_port/os_flag.c ****                      if (rdy == TRUE) {                       
 3494              		.loc 1 821 0
 3495 10f4 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3496 10f8 010053E3 		cmp	r3, #1
 3497 10fc 1700001A 		bne	.L120
 822:../os_port/os_flag.c ****                          sched = TRUE;                        /* When done we will reschedule      
 3498              		.loc 1 822 0
 3499 1100 0130A0E3 		mov	r3, #1
 3500 1104 11304BE5 		strb	r3, [fp, #-17]
 823:../os_port/os_flag.c ****                      }
 824:../os_port/os_flag.c ****                  }
 825:../os_port/os_flag.c ****                  break;
 3501              		.loc 1 825 0
 3502 1108 150000EA 		b	.L106
 3503              	.L99:
 826:../os_port/os_flag.c **** #endif
 827:../os_port/os_flag.c ****             default:
 828:../os_port/os_flag.c ****                  OS_EXIT_CRITICAL();
 3504              		.loc 1 828 0
 3505              	@ 828 "../os_port/os_flag.c" 1
 3506 110c 04009DE4 		ldmfd sp!, {r0}
 3507              	@ 0 "" 2
 3508              	@ 828 "../os_port/os_flag.c" 1
 3509 1110 00F021E1 		msr   cpsr_c, r0
 3510              	@ 0 "" 2
 829:../os_port/os_flag.c ****                  *err = OS_FLAG_ERR_WAIT_TYPE;
 3511              		.loc 1 829 0
 3512 1114 28301BE5 		ldr	r3, [fp, #-40]
 3513 1118 6820E0E3 		mvn	r2, #104
 3514 111c 0020C3E5 		strb	r2, [r3, #0]
 830:../os_port/os_flag.c ****                  return ((OS_FLAGS)0);
 3515              		.loc 1 830 0
 3516 1120 0030A0E3 		mov	r3, #0
 3517 1124 270000EA 		b	.L92
 3518              	.L113:
 794:../os_port/os_flag.c ****                  break;
 3519              		.loc 1 794 0
 3520 1128 0000A0E1 		mov	r0, r0	@ nop
 3521 112c 0C0000EA 		b	.L106
 3522              	.L114:
 3523 1130 0000A0E1 		mov	r0, r0	@ nop
 3524 1134 0A0000EA 		b	.L106
 3525              	.L115:
 804:../os_port/os_flag.c ****                  break;
 3526              		.loc 1 804 0
 3527 1138 0000A0E1 		mov	r0, r0	@ nop
 3528 113c 080000EA 		b	.L106
 3529              	.L116:
 3530 1140 0000A0E1 		mov	r0, r0	@ nop
 3531 1144 060000EA 		b	.L106
 3532              	.L117:
 815:../os_port/os_flag.c ****                  break;
 3533              		.loc 1 815 0
 3534 1148 0000A0E1 		mov	r0, r0	@ nop
 3535 114c 040000EA 		b	.L106
 3536              	.L118:
 3537 1150 0000A0E1 		mov	r0, r0	@ nop
 3538 1154 020000EA 		b	.L106
 3539              	.L119:
 825:../os_port/os_flag.c ****                  break;
 3540              		.loc 1 825 0
 3541 1158 0000A0E1 		mov	r0, r0	@ nop
 3542 115c 000000EA 		b	.L106
 3543              	.L120:
 3544 1160 0000A0E1 		mov	r0, r0	@ nop
 3545              	.L106:
 831:../os_port/os_flag.c ****         }
 832:../os_port/os_flag.c ****         pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag
 3546              		.loc 1 832 0
 3547 1164 10301BE5 		ldr	r3, [fp, #-16]
 3548 1168 003093E5 		ldr	r3, [r3, #0]
 3549 116c 10300BE5 		str	r3, [fp, #-16]
 3550              	.L98:
 784:../os_port/os_flag.c ****     while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(
 3551              		.loc 1 784 0 discriminator 1
 3552 1170 10301BE5 		ldr	r3, [fp, #-16]
 3553 1174 000053E3 		cmp	r3, #0
 3554 1178 70FFFF1A 		bne	.L110
 833:../os_port/os_flag.c ****     }
 834:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 3555              		.loc 1 834 0
 3556              	@ 834 "../os_port/os_flag.c" 1
 3557 117c 04009DE4 		ldmfd sp!, {r0}
 3558              	@ 0 "" 2
 3559              	@ 834 "../os_port/os_flag.c" 1
 3560 1180 00F021E1 		msr   cpsr_c, r0
 3561              	@ 0 "" 2
 835:../os_port/os_flag.c ****     if (sched == TRUE) {
 3562              		.loc 1 835 0
 3563 1184 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3564 1188 010053E3 		cmp	r3, #1
 3565 118c 0000001A 		bne	.L111
 836:../os_port/os_flag.c ****         OS_Sched();
 3566              		.loc 1 836 0
 3567 1190 FEFFFFEB 		bl	OS_Sched
 3568              	.L111:
 837:../os_port/os_flag.c ****     }
 838:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 3569              		.loc 1 838 0
 3570              	@ 838 "../os_port/os_flag.c" 1
 3571 1194 00000FE1 		mrs   r0, cpsr
 3572              	@ 0 "" 2
 3573              	@ 838 "../os_port/os_flag.c" 1
 3574 1198 04002DE5 		stmfd sp!, {r0}
 3575              	@ 0 "" 2
 3576              	@ 838 "../os_port/os_flag.c" 1
 3577 119c C00080E3 		orr   r0, r0, #0b11000000
 3578              	@ 0 "" 2
 3579              	@ 838 "../os_port/os_flag.c" 1
 3580 11a0 00F021E1 		msr   cpsr_c, r0
 3581              	@ 0 "" 2
 839:../os_port/os_flag.c ****     flags_cur = pgrp->OSFlagFlags;
 3582              		.loc 1 839 0
 3583 11a4 20301BE5 		ldr	r3, [fp, #-32]
 3584 11a8 B830D3E1 		ldrh	r3, [r3, #8]	@ movhi
 3585 11ac B8314BE1 		strh	r3, [fp, #-24]	@ movhi
 840:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 3586              		.loc 1 840 0
 3587              	@ 840 "../os_port/os_flag.c" 1
 3588 11b0 04009DE4 		ldmfd sp!, {r0}
 3589              	@ 0 "" 2
 3590              	@ 840 "../os_port/os_flag.c" 1
 3591 11b4 00F021E1 		msr   cpsr_c, r0
 3592              	@ 0 "" 2
 841:../os_port/os_flag.c ****     *err      = OS_NO_ERR;
 3593              		.loc 1 841 0
 3594 11b8 28301BE5 		ldr	r3, [fp, #-40]
 3595 11bc 0020A0E3 		mov	r2, #0
 3596 11c0 0020C3E5 		strb	r2, [r3, #0]
 842:../os_port/os_flag.c ****     return (flags_cur);
 3597              		.loc 1 842 0
 3598 11c4 B8315BE1 		ldrh	r3, [fp, #-24]
 3599              	.L92:
 843:../os_port/os_flag.c **** }
 3600              		.loc 1 843 0
 3601 11c8 0300A0E1 		mov	r0, r3
 3602 11cc 0CD04BE2 		sub	sp, fp, #12
 3603 11d0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3604 11d4 1EFF2FE1 		bx	lr
 3605              		.cfi_endproc
 3606              	.LFE7:
 3608              		.align	2
 3609              		.global	OSFlagQuery
 3611              	OSFlagQuery:
 3612              	.LFB8:
 844:../os_port/os_flag.c **** /*$PAGE*/
 845:../os_port/os_flag.c **** /*
 846:../os_port/os_flag.c **** ***************************************************************************************************
 847:../os_port/os_flag.c **** *                                           QUERY EVENT FLAG
 848:../os_port/os_flag.c **** *
 849:../os_port/os_flag.c **** * Description: This function is used to check the value of the event flag group.
 850:../os_port/os_flag.c **** *
 851:../os_port/os_flag.c **** * Arguments  : pgrp         is a pointer to the desired event flag group.
 852:../os_port/os_flag.c **** *
 853:../os_port/os_flag.c **** *              err           is a pointer to an error code returned to the called:
 854:../os_port/os_flag.c **** *                            OS_NO_ERR              The call was successfull
 855:../os_port/os_flag.c **** *                            OS_FLAG_INVALID_PGRP   You passed a NULL pointer
 856:../os_port/os_flag.c **** *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
 857:../os_port/os_flag.c **** *
 858:../os_port/os_flag.c **** * Returns    : The current value of the event flag group.
 859:../os_port/os_flag.c **** *
 860:../os_port/os_flag.c **** * Called From: Task or ISR
 861:../os_port/os_flag.c **** ***************************************************************************************************
 862:../os_port/os_flag.c **** */
 863:../os_port/os_flag.c **** 
 864:../os_port/os_flag.c **** #if OS_FLAG_QUERY_EN > 0
 865:../os_port/os_flag.c **** OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *err)
 866:../os_port/os_flag.c **** {
 3613              		.loc 1 866 0
 3614              		.cfi_startproc
 3615              		@ Function supports interworking.
 3616              		@ args = 0, pretend = 0, frame = 16
 3617              		@ frame_needed = 1, uses_anonymous_args = 0
 3618 11d8 0DC0A0E1 		mov	ip, sp
 3619              	.LCFI16:
 3620              		.cfi_def_cfa_register 12
 3621 11dc 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3622 11e0 04B04CE2 		sub	fp, ip, #4
 3623              		.cfi_offset 14, -8
 3624              		.cfi_offset 13, -12
 3625              		.cfi_offset 11, -16
 3626              	.LCFI17:
 3627              		.cfi_def_cfa 11, 4
 3628 11e4 10D04DE2 		sub	sp, sp, #16
 3629 11e8 18000BE5 		str	r0, [fp, #-24]
 3630 11ec 1C100BE5 		str	r1, [fp, #-28]
 867:../os_port/os_flag.c ****     OS_FLAGS   flags;
 868:../os_port/os_flag.c **** #if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register      
 869:../os_port/os_flag.c ****     OS_CPU_SR  cpu_sr;
 870:../os_port/os_flag.c **** 
 871:../os_port/os_flag.c **** 
 872:../os_port/os_flag.c **** 
 873:../os_port/os_flag.c ****     cpu_sr = 0;                                   /* Prevent compiler warning                      
 874:../os_port/os_flag.c **** #endif    
 875:../os_port/os_flag.c **** #if OS_ARG_CHK_EN > 0
 876:../os_port/os_flag.c ****     if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                               
 3631              		.loc 1 876 0
 3632 11f0 18301BE5 		ldr	r3, [fp, #-24]
 3633 11f4 000053E3 		cmp	r3, #0
 3634 11f8 0400001A 		bne	.L122
 877:../os_port/os_flag.c ****         *err = OS_FLAG_INVALID_PGRP;
 3635              		.loc 1 877 0
 3636 11fc 1C301BE5 		ldr	r3, [fp, #-28]
 3637 1200 6920E0E3 		mvn	r2, #105
 3638 1204 0020C3E5 		strb	r2, [r3, #0]
 878:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 3639              		.loc 1 878 0
 3640 1208 0030A0E3 		mov	r3, #0
 3641 120c 150000EA 		b	.L123
 3642              	.L122:
 879:../os_port/os_flag.c ****     }
 880:../os_port/os_flag.c **** #endif
 881:../os_port/os_flag.c ****     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                     
 3643              		.loc 1 881 0
 3644 1210 18301BE5 		ldr	r3, [fp, #-24]
 3645 1214 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3646 1218 050053E3 		cmp	r3, #5
 3647 121c 0400000A 		beq	.L124
 882:../os_port/os_flag.c ****         *err = OS_ERR_EVENT_TYPE;
 3648              		.loc 1 882 0
 3649 1220 1C301BE5 		ldr	r3, [fp, #-28]
 3650 1224 0120A0E3 		mov	r2, #1
 3651 1228 0020C3E5 		strb	r2, [r3, #0]
 883:../os_port/os_flag.c ****         return ((OS_FLAGS)0);
 3652              		.loc 1 883 0
 3653 122c 0030A0E3 		mov	r3, #0
 3654 1230 0C0000EA 		b	.L123
 3655              	.L124:
 884:../os_port/os_flag.c ****     }
 885:../os_port/os_flag.c ****     OS_ENTER_CRITICAL();
 3656              		.loc 1 885 0
 3657              	@ 885 "../os_port/os_flag.c" 1
 3658 1234 00000FE1 		mrs   r0, cpsr
 3659              	@ 0 "" 2
 3660              	@ 885 "../os_port/os_flag.c" 1
 3661 1238 04002DE5 		stmfd sp!, {r0}
 3662              	@ 0 "" 2
 3663              	@ 885 "../os_port/os_flag.c" 1
 3664 123c C00080E3 		orr   r0, r0, #0b11000000
 3665              	@ 0 "" 2
 3666              	@ 885 "../os_port/os_flag.c" 1
 3667 1240 00F021E1 		msr   cpsr_c, r0
 3668              	@ 0 "" 2
 886:../os_port/os_flag.c ****     flags = pgrp->OSFlagFlags;
 3669              		.loc 1 886 0
 3670 1244 18301BE5 		ldr	r3, [fp, #-24]
 3671 1248 B830D3E1 		ldrh	r3, [r3, #8]	@ movhi
 3672 124c BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 887:../os_port/os_flag.c ****     OS_EXIT_CRITICAL();
 3673              		.loc 1 887 0
 3674              	@ 887 "../os_port/os_flag.c" 1
 3675 1250 04009DE4 		ldmfd sp!, {r0}
 3676              	@ 0 "" 2
 3677              	@ 887 "../os_port/os_flag.c" 1
 3678 1254 00F021E1 		msr   cpsr_c, r0
 3679              	@ 0 "" 2
 888:../os_port/os_flag.c ****     *err = OS_NO_ERR;
 3680              		.loc 1 888 0
 3681 1258 1C301BE5 		ldr	r3, [fp, #-28]
 3682 125c 0020A0E3 		mov	r2, #0
 3683 1260 0020C3E5 		strb	r2, [r3, #0]
 889:../os_port/os_flag.c ****     return (flags);                               /* Return the current value of the event flags   
 3684              		.loc 1 889 0
 3685 1264 BE305BE1 		ldrh	r3, [fp, #-14]
 3686              	.L123:
 890:../os_port/os_flag.c **** }
 3687              		.loc 1 890 0
 3688 1268 0300A0E1 		mov	r0, r3
 3689 126c 0CD04BE2 		sub	sp, fp, #12
 3690 1270 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3691 1274 1EFF2FE1 		bx	lr
 3692              		.cfi_endproc
 3693              	.LFE8:
 3695              		.align	2
 3697              	OS_FlagBlock:
 3698              	.LFB9:
 891:../os_port/os_flag.c **** #endif
 892:../os_port/os_flag.c **** 
 893:../os_port/os_flag.c **** /*$PAGE*/
 894:../os_port/os_flag.c **** /*
 895:../os_port/os_flag.c **** ***************************************************************************************************
 896:../os_port/os_flag.c **** *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
 897:../os_port/os_flag.c **** *
 898:../os_port/os_flag.c **** * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the d
 899:../os_port/os_flag.c **** *              event flag bit(s) are set.
 900:../os_port/os_flag.c **** *
 901:../os_port/os_flag.c **** * Arguments  : pgrp          is a pointer to the desired event flag group.
 902:../os_port/os_flag.c **** *
 903:../os_port/os_flag.c **** *              pnode         is a pointer to a structure which contains data about the task waiting
 904:../os_port/os_flag.c **** *                            event flag bit(s) to be set.
 905:../os_port/os_flag.c **** *
 906:../os_port/os_flag.c **** *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to chec
 907:../os_port/os_flag.c **** *                            The bits you want are specified by setting the corresponding bits in
 908:../os_port/os_flag.c **** *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
 909:../os_port/os_flag.c **** *                            'flags' would contain 0x03.
 910:../os_port/os_flag.c **** *
 911:../os_port/os_flag.c **** *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bi
 912:../os_port/os_flag.c **** *                            to be set/cleared.
 913:../os_port/os_flag.c **** *                            You can specify the following argument:
 914:../os_port/os_flag.c **** *
 915:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (
 916:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (
 917:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (
 918:../os_port/os_flag.c **** *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (
 919:../os_port/os_flag.c **** *
 920:../os_port/os_flag.c **** *              timeout       is the desired amount of time that the task will wait for the event fl
 921:../os_port/os_flag.c **** *                            bit(s) to be set.
 922:../os_port/os_flag.c **** *
 923:../os_port/os_flag.c **** * Returns    : none
 924:../os_port/os_flag.c **** *
 925:../os_port/os_flag.c **** * Called by  : OSFlagPend()  OS_FLAG.C
 926:../os_port/os_flag.c **** *
 927:../os_port/os_flag.c **** * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
 928:../os_port/os_flag.c **** ***************************************************************************************************
 929:../os_port/os_flag.c **** */
 930:../os_port/os_flag.c **** 
 931:../os_port/os_flag.c **** static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type
 932:../os_port/os_flag.c **** {
 3699              		.loc 1 932 0
 3700              		.cfi_startproc
 3701              		@ Function supports interworking.
 3702              		@ args = 4, pretend = 0, frame = 24
 3703              		@ frame_needed = 1, uses_anonymous_args = 0
 3704 1278 0DC0A0E1 		mov	ip, sp
 3705              	.LCFI18:
 3706              		.cfi_def_cfa_register 12
 3707 127c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3708 1280 04B04CE2 		sub	fp, ip, #4
 3709              		.cfi_offset 14, -8
 3710              		.cfi_offset 13, -12
 3711              		.cfi_offset 11, -16
 3712              	.LCFI19:
 3713              		.cfi_def_cfa 11, 4
 3714 1284 18D04DE2 		sub	sp, sp, #24
 3715 1288 18000BE5 		str	r0, [fp, #-24]
 3716 128c 1C100BE5 		str	r1, [fp, #-28]
 3717 1290 BE214BE1 		strh	r2, [fp, #-30]	@ movhi
 3718 1294 1F304BE5 		strb	r3, [fp, #-31]
 933:../os_port/os_flag.c ****     OS_FLAG_NODE  *pnode_next;
 934:../os_port/os_flag.c **** 	INT8U          y;
 935:../os_port/os_flag.c **** 
 936:../os_port/os_flag.c **** 
 937:../os_port/os_flag.c ****     OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 3719              		.loc 1 937 0
 3720 1298 80319FE5 		ldr	r3, .L128
 3721 129c 003093E5 		ldr	r3, [r3, #0]
 3722 12a0 78219FE5 		ldr	r2, .L128
 3723 12a4 002092E5 		ldr	r2, [r2, #0]
 3724 12a8 2C20D2E5 		ldrb	r2, [r2, #44]	@ zero_extendqisi2
 3725 12ac 202082E3 		orr	r2, r2, #32
 3726 12b0 FF2002E2 		and	r2, r2, #255
 3727 12b4 2C20C3E5 		strb	r2, [r3, #44]
 938:../os_port/os_flag.c ****     OSTCBCur->OSTCBPendTO     = FALSE;
 3728              		.loc 1 938 0
 3729 12b8 60319FE5 		ldr	r3, .L128
 3730 12bc 003093E5 		ldr	r3, [r3, #0]
 3731 12c0 0020A0E3 		mov	r2, #0
 3732 12c4 2D20C3E5 		strb	r2, [r3, #45]
 939:../os_port/os_flag.c ****     OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB               
 3733              		.loc 1 939 0
 3734 12c8 50319FE5 		ldr	r3, .L128
 3735 12cc 003093E5 		ldr	r3, [r3, #0]
 3736 12d0 B420DBE1 		ldrh	r2, [fp, #4]	@ movhi
 3737 12d4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
 940:../os_port/os_flag.c ****     OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
 3738              		.loc 1 940 0
 3739 12d8 40319FE5 		ldr	r3, .L128
 3740 12dc 003093E5 		ldr	r3, [r3, #0]
 3741 12e0 0020A0E3 		mov	r2, #0
 3742 12e4 1C2083E5 		str	r2, [r3, #28]
 941:../os_port/os_flag.c **** #if OS_TASK_DEL_EN > 0
 942:../os_port/os_flag.c ****     OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                       
 3743              		.loc 1 942 0
 3744 12e8 30319FE5 		ldr	r3, .L128
 3745 12ec 003093E5 		ldr	r3, [r3, #0]
 3746 12f0 1C201BE5 		ldr	r2, [fp, #-28]
 3747 12f4 242083E5 		str	r2, [r3, #36]
 943:../os_port/os_flag.c **** #endif
 944:../os_port/os_flag.c ****     pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for   
 3748              		.loc 1 944 0
 3749 12f8 1C301BE5 		ldr	r3, [fp, #-28]
 3750 12fc BE215BE1 		ldrh	r2, [fp, #-30]	@ movhi
 3751 1300 B021C3E1 		strh	r2, [r3, #16]	@ movhi
 945:../os_port/os_flag.c ****     pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing        
 3752              		.loc 1 945 0
 3753 1304 1C301BE5 		ldr	r3, [fp, #-28]
 3754 1308 1F205BE5 		ldrb	r2, [fp, #-31]
 3755 130c 1220C3E5 		strb	r2, [r3, #18]
 946:../os_port/os_flag.c ****     pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                        
 3756              		.loc 1 946 0
 3757 1310 08319FE5 		ldr	r3, .L128
 3758 1314 002093E5 		ldr	r2, [r3, #0]
 3759 1318 1C301BE5 		ldr	r3, [fp, #-28]
 3760 131c 082083E5 		str	r2, [r3, #8]
 947:../os_port/os_flag.c ****     pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait l
 3761              		.loc 1 947 0
 3762 1320 18301BE5 		ldr	r3, [fp, #-24]
 3763 1324 042093E5 		ldr	r2, [r3, #4]
 3764 1328 1C301BE5 		ldr	r3, [fp, #-28]
 3765 132c 002083E5 		str	r2, [r3, #0]
 948:../os_port/os_flag.c ****     pnode->OSFlagNodePrev     = (void *)0;
 3766              		.loc 1 948 0
 3767 1330 1C301BE5 		ldr	r3, [fp, #-28]
 3768 1334 0020A0E3 		mov	r2, #0
 3769 1338 042083E5 		str	r2, [r3, #4]
 949:../os_port/os_flag.c ****     pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                  
 3770              		.loc 1 949 0
 3771 133c 1C301BE5 		ldr	r3, [fp, #-28]
 3772 1340 18201BE5 		ldr	r2, [fp, #-24]
 3773 1344 0C2083E5 		str	r2, [r3, #12]
 950:../os_port/os_flag.c ****     pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3774              		.loc 1 950 0
 3775 1348 18301BE5 		ldr	r3, [fp, #-24]
 3776 134c 043093E5 		ldr	r3, [r3, #4]
 3777 1350 10300BE5 		str	r3, [fp, #-16]
 951:../os_port/os_flag.c ****     if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?         
 3778              		.loc 1 951 0
 3779 1354 10301BE5 		ldr	r3, [fp, #-16]
 3780 1358 000053E3 		cmp	r3, #0
 3781 135c 0200000A 		beq	.L126
 952:../os_port/os_flag.c ****         pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list            
 3782              		.loc 1 952 0
 3783 1360 10301BE5 		ldr	r3, [fp, #-16]
 3784 1364 1C201BE5 		ldr	r2, [fp, #-28]
 3785 1368 042083E5 		str	r2, [r3, #4]
 3786              	.L126:
 953:../os_port/os_flag.c ****     }
 954:../os_port/os_flag.c ****     pgrp->OSFlagWaitList = (void *)pnode;
 3787              		.loc 1 954 0
 3788 136c 18301BE5 		ldr	r3, [fp, #-24]
 3789 1370 1C201BE5 		ldr	r2, [fp, #-28]
 3790 1374 042083E5 		str	r2, [r3, #4]
 955:../os_port/os_flag.c ****                                                       
 956:../os_port/os_flag.c ****     y            =  OSTCBCur->OSTCBY;		 	      /* Suspend current task until flag(s) received   */
 3791              		.loc 1 956 0
 3792 1378 A0309FE5 		ldr	r3, .L128
 3793 137c 003093E5 		ldr	r3, [r3, #0]
 3794 1380 3030D3E5 		ldrb	r3, [r3, #48]
 3795 1384 11304BE5 		strb	r3, [fp, #-17]
 957:../os_port/os_flag.c **** 	OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 3796              		.loc 1 957 0
 3797 1388 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3798 138c 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 3799 1390 8C109FE5 		ldr	r1, .L128+4
 3800 1394 0220D1E7 		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 3801 1398 FF1002E2 		and	r1, r2, #255
 3802 139c 7C209FE5 		ldr	r2, .L128
 3803 13a0 002092E5 		ldr	r2, [r2, #0]
 3804 13a4 3120D2E5 		ldrb	r2, [r2, #49]	@ zero_extendqisi2
 3805 13a8 FF2002E2 		and	r2, r2, #255
 3806 13ac 0220E0E1 		mvn	r2, r2
 3807 13b0 FF2002E2 		and	r2, r2, #255
 3808 13b4 022001E0 		and	r2, r1, r2
 3809 13b8 FF2002E2 		and	r2, r2, #255
 3810 13bc FF1002E2 		and	r1, r2, #255
 3811 13c0 5C209FE5 		ldr	r2, .L128+4
 3812 13c4 0310C2E7 		strb	r1, [r2, r3]
 958:../os_port/os_flag.c ****     if (OSRdyTbl[y] == 0x00) {
 3813              		.loc 1 958 0
 3814 13c8 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3815 13cc 50209FE5 		ldr	r2, .L128+4
 3816 13d0 0330D2E7 		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 3817 13d4 000053E3 		cmp	r3, #0
 3818 13d8 0D00001A 		bne	.L125
 959:../os_port/os_flag.c ****         OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 3819              		.loc 1 959 0
 3820 13dc 3C309FE5 		ldr	r3, .L128
 3821 13e0 003093E5 		ldr	r3, [r3, #0]
 3822 13e4 3230D3E5 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 3823 13e8 FF3003E2 		and	r3, r3, #255
 3824 13ec 0330E0E1 		mvn	r3, r3
 3825 13f0 FF2003E2 		and	r2, r3, #255
 3826 13f4 2C309FE5 		ldr	r3, .L128+8
 3827 13f8 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3828 13fc FF3003E2 		and	r3, r3, #255
 3829 1400 033002E0 		and	r3, r2, r3
 3830 1404 FF3003E2 		and	r3, r3, #255
 3831 1408 FF2003E2 		and	r2, r3, #255
 3832 140c 14309FE5 		ldr	r3, .L128+8
 3833 1410 0020C3E5 		strb	r2, [r3, #0]
 3834              	.L125:
 960:../os_port/os_flag.c ****     }
 961:../os_port/os_flag.c **** }
 3835              		.loc 1 961 0
 3836 1414 0CD04BE2 		sub	sp, fp, #12
 3837 1418 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3838 141c 1EFF2FE1 		bx	lr
 3839              	.L129:
 3840              		.align	2
 3841              	.L128:
 3842 1420 00000000 		.word	OSTCBCur
 3843 1424 00000000 		.word	OSRdyTbl
 3844 1428 00000000 		.word	OSRdyGrp
 3845              		.cfi_endproc
 3846              	.LFE9:
 3848              		.align	2
 3849              		.global	OS_FlagInit
 3851              	OS_FlagInit:
 3852              	.LFB10:
 962:../os_port/os_flag.c **** 
 963:../os_port/os_flag.c **** /*$PAGE*/
 964:../os_port/os_flag.c **** /*
 965:../os_port/os_flag.c **** ***************************************************************************************************
 966:../os_port/os_flag.c **** *                                    INITIALIZE THE EVENT FLAG MODULE
 967:../os_port/os_flag.c **** *
 968:../os_port/os_flag.c **** * Description: This function is called by uC/OS-II to initialize the event flag module.  Your appli
 969:../os_port/os_flag.c **** *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
 970:../os_port/os_flag.c **** *
 971:../os_port/os_flag.c **** * Arguments  : none
 972:../os_port/os_flag.c **** *
 973:../os_port/os_flag.c **** * Returns    : none
 974:../os_port/os_flag.c **** *
 975:../os_port/os_flag.c **** * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/
 976:../os_port/os_flag.c **** ***************************************************************************************************
 977:../os_port/os_flag.c **** */
 978:../os_port/os_flag.c **** 
 979:../os_port/os_flag.c **** void  OS_FlagInit (void)
 980:../os_port/os_flag.c **** {
 3853              		.loc 1 980 0
 3854              		.cfi_startproc
 3855              		@ Function supports interworking.
 3856              		@ args = 0, pretend = 0, frame = 16
 3857              		@ frame_needed = 1, uses_anonymous_args = 0
 3858 142c 0DC0A0E1 		mov	ip, sp
 3859              	.LCFI20:
 3860              		.cfi_def_cfa_register 12
 3861 1430 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3862 1434 04B04CE2 		sub	fp, ip, #4
 3863              		.cfi_offset 14, -8
 3864              		.cfi_offset 13, -12
 3865              		.cfi_offset 11, -16
 3866              	.LCFI21:
 3867              		.cfi_def_cfa 11, 4
 3868 1438 10D04DE2 		sub	sp, sp, #16
 981:../os_port/os_flag.c **** #if OS_MAX_FLAGS == 1
 982:../os_port/os_flag.c ****     OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!  
 983:../os_port/os_flag.c ****     OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 984:../os_port/os_flag.c ****     OSFlagFreeList->OSFlagWaitList = (void *)0;
 985:../os_port/os_flag.c ****     OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
 986:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
 987:../os_port/os_flag.c ****     OSFlagFreeList->OSFlagName[0]  = '?';
 988:../os_port/os_flag.c ****     OSFlagFreeList->OSFlagName[1]  = OS_ASCII_NUL;
 989:../os_port/os_flag.c **** #endif
 990:../os_port/os_flag.c **** #endif
 991:../os_port/os_flag.c **** 
 992:../os_port/os_flag.c **** #if OS_MAX_FLAGS >= 2
 993:../os_port/os_flag.c ****     INT16U       i;
 994:../os_port/os_flag.c ****     OS_FLAG_GRP *pgrp1;
 995:../os_port/os_flag.c ****     OS_FLAG_GRP *pgrp2;
 996:../os_port/os_flag.c **** 
 997:../os_port/os_flag.c **** 
 998:../os_port/os_flag.c ****     OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table  
 3869              		.loc 1 998 0
 3870 143c CC309FE5 		ldr	r3, .L133
 3871 1440 0300A0E1 		mov	r0, r3
 3872 1444 DC10A0E3 		mov	r1, #220
 3873 1448 FEFFFFEB 		bl	OS_MemClr
 999:../os_port/os_flag.c ****     pgrp1 = &OSFlagTbl[0];
 3874              		.loc 1 999 0
 3875 144c BC309FE5 		ldr	r3, .L133
 3876 1450 14300BE5 		str	r3, [fp, #-20]
1000:../os_port/os_flag.c ****     pgrp2 = &OSFlagTbl[1];
 3877              		.loc 1 1000 0
 3878 1454 B8309FE5 		ldr	r3, .L133+4
 3879 1458 18300BE5 		str	r3, [fp, #-24]
1001:../os_port/os_flag.c ****     for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLA
 3880              		.loc 1 1001 0
 3881 145c 0030A0E3 		mov	r3, #0
 3882 1460 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 3883 1464 140000EA 		b	.L131
 3884              	.L132:
1002:../os_port/os_flag.c ****         pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3885              		.loc 1 1002 0 discriminator 2
 3886 1468 14301BE5 		ldr	r3, [fp, #-20]
 3887 146c 0020A0E3 		mov	r2, #0
 3888 1470 0020C3E5 		strb	r2, [r3, #0]
1003:../os_port/os_flag.c ****         pgrp1->OSFlagWaitList = (void *)pgrp2;
 3889              		.loc 1 1003 0 discriminator 2
 3890 1474 14301BE5 		ldr	r3, [fp, #-20]
 3891 1478 18201BE5 		ldr	r2, [fp, #-24]
 3892 147c 042083E5 		str	r2, [r3, #4]
1004:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
1005:../os_port/os_flag.c ****         pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                
 3893              		.loc 1 1005 0 discriminator 2
 3894 1480 14301BE5 		ldr	r3, [fp, #-20]
 3895 1484 3F20A0E3 		mov	r2, #63
 3896 1488 0A20C3E5 		strb	r2, [r3, #10]
1006:../os_port/os_flag.c ****         pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 3897              		.loc 1 1006 0 discriminator 2
 3898 148c 14301BE5 		ldr	r3, [fp, #-20]
 3899 1490 0020A0E3 		mov	r2, #0
 3900 1494 0B20C3E5 		strb	r2, [r3, #11]
1007:../os_port/os_flag.c **** #endif
1008:../os_port/os_flag.c ****         pgrp1++;
 3901              		.loc 1 1008 0 discriminator 2
 3902 1498 14301BE5 		ldr	r3, [fp, #-20]
 3903 149c 2C3083E2 		add	r3, r3, #44
 3904 14a0 14300BE5 		str	r3, [fp, #-20]
1009:../os_port/os_flag.c ****         pgrp2++;
 3905              		.loc 1 1009 0 discriminator 2
 3906 14a4 18301BE5 		ldr	r3, [fp, #-24]
 3907 14a8 2C3083E2 		add	r3, r3, #44
 3908 14ac 18300BE5 		str	r3, [fp, #-24]
1001:../os_port/os_flag.c ****     for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLA
 3909              		.loc 1 1001 0 discriminator 2
 3910 14b0 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 3911 14b4 013083E2 		add	r3, r3, #1
 3912 14b8 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 3913              	.L131:
1001:../os_port/os_flag.c ****     for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLA
 3914              		.loc 1 1001 0 is_stmt 0 discriminator 1
 3915 14bc BE305BE1 		ldrh	r3, [fp, #-14]
 3916 14c0 030053E3 		cmp	r3, #3
 3917 14c4 E7FFFF9A 		bls	.L132
1010:../os_port/os_flag.c ****     }
1011:../os_port/os_flag.c ****     pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3918              		.loc 1 1011 0 is_stmt 1
 3919 14c8 14301BE5 		ldr	r3, [fp, #-20]
 3920 14cc 0020A0E3 		mov	r2, #0
 3921 14d0 0020C3E5 		strb	r2, [r3, #0]
1012:../os_port/os_flag.c ****     pgrp1->OSFlagWaitList = (void *)0;
 3922              		.loc 1 1012 0
 3923 14d4 14301BE5 		ldr	r3, [fp, #-20]
 3924 14d8 0020A0E3 		mov	r2, #0
 3925 14dc 042083E5 		str	r2, [r3, #4]
1013:../os_port/os_flag.c **** #if OS_FLAG_NAME_SIZE > 1
1014:../os_port/os_flag.c ****     pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                
 3926              		.loc 1 1014 0
 3927 14e0 14301BE5 		ldr	r3, [fp, #-20]
 3928 14e4 3F20A0E3 		mov	r2, #63
 3929 14e8 0A20C3E5 		strb	r2, [r3, #10]
1015:../os_port/os_flag.c ****     pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 3930              		.loc 1 1015 0
 3931 14ec 14301BE5 		ldr	r3, [fp, #-20]
 3932 14f0 0020A0E3 		mov	r2, #0
 3933 14f4 0B20C3E5 		strb	r2, [r3, #11]
1016:../os_port/os_flag.c **** #endif
1017:../os_port/os_flag.c ****     OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];
 3934              		.loc 1 1017 0
 3935 14f8 18309FE5 		ldr	r3, .L133+8
 3936 14fc 0C209FE5 		ldr	r2, .L133
 3937 1500 002083E5 		str	r2, [r3, #0]
1018:../os_port/os_flag.c **** #endif
1019:../os_port/os_flag.c **** }
 3938              		.loc 1 1019 0
 3939 1504 0CD04BE2 		sub	sp, fp, #12
 3940 1508 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3941 150c 1EFF2FE1 		bx	lr
 3942              	.L134:
 3943              		.align	2
 3944              	.L133:
 3945 1510 00000000 		.word	OSFlagTbl
 3946 1514 2C000000 		.word	OSFlagTbl+44
 3947 1518 00000000 		.word	OSFlagFreeList
 3948              		.cfi_endproc
 3949              	.LFE10:
 3951              		.align	2
 3953              	OS_FlagTaskRdy:
 3954              	.LFB11:
1020:../os_port/os_flag.c **** 
1021:../os_port/os_flag.c **** /*$PAGE*/
1022:../os_port/os_flag.c **** /*
1023:../os_port/os_flag.c **** ***************************************************************************************************
1024:../os_port/os_flag.c **** *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
1025:../os_port/os_flag.c **** *
1026:../os_port/os_flag.c **** * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run becaus
1027:../os_port/os_flag.c **** *              desired event flag bits have been set.
1028:../os_port/os_flag.c **** *
1029:../os_port/os_flag.c **** * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting
1030:../os_port/os_flag.c **** *                            event flag bit(s) to be set.
1031:../os_port/os_flag.c **** *
1032:../os_port/os_flag.c **** *              flags_rdy     contains the bit pattern of the event flags that cause the task to bec
1033:../os_port/os_flag.c **** *                            ready-to-run.
1034:../os_port/os_flag.c **** *
1035:../os_port/os_flag.c **** * Returns    : TRUE          If the task has been placed in the ready list and thus needs schedulin
1036:../os_port/os_flag.c **** *              FALSE         The task is still not ready to run and thus scheduling is not necessar
1037:../os_port/os_flag.c **** *
1038:../os_port/os_flag.c **** * Called by  : OSFlagsPost() OS_FLAG.C
1039:../os_port/os_flag.c **** *
1040:../os_port/os_flag.c **** * Note(s)    : 1) This function assumes that interrupts are disabled.
1041:../os_port/os_flag.c **** *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
1042:../os_port/os_flag.c **** ***************************************************************************************************
1043:../os_port/os_flag.c **** */
1044:../os_port/os_flag.c **** 
1045:../os_port/os_flag.c **** static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
1046:../os_port/os_flag.c **** {
 3955              		.loc 1 1046 0
 3956              		.cfi_startproc
 3957              		@ Function supports interworking.
 3958              		@ args = 0, pretend = 0, frame = 16
 3959              		@ frame_needed = 1, uses_anonymous_args = 0
 3960 151c 0DC0A0E1 		mov	ip, sp
 3961              	.LCFI22:
 3962              		.cfi_def_cfa_register 12
 3963 1520 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3964 1524 04B04CE2 		sub	fp, ip, #4
 3965              		.cfi_offset 14, -8
 3966              		.cfi_offset 13, -12
 3967              		.cfi_offset 11, -16
 3968              	.LCFI23:
 3969              		.cfi_def_cfa 11, 4
 3970 1528 10D04DE2 		sub	sp, sp, #16
 3971 152c 18000BE5 		str	r0, [fp, #-24]
 3972 1530 0130A0E1 		mov	r3, r1
 3973 1534 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
1047:../os_port/os_flag.c ****     OS_TCB   *ptcb;
1048:../os_port/os_flag.c ****     BOOLEAN   sched;
1049:../os_port/os_flag.c **** 
1050:../os_port/os_flag.c **** 
1051:../os_port/os_flag.c ****     ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task         
 3974              		.loc 1 1051 0
 3975 1538 18301BE5 		ldr	r3, [fp, #-24]
 3976 153c 083093E5 		ldr	r3, [r3, #8]
 3977 1540 14300BE5 		str	r3, [fp, #-20]
1052:../os_port/os_flag.c ****     ptcb->OSTCBDly      = 0;
 3978              		.loc 1 1052 0
 3979 1544 14301BE5 		ldr	r3, [fp, #-20]
 3980 1548 0020A0E3 		mov	r2, #0
 3981 154c BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1053:../os_port/os_flag.c ****     ptcb->OSTCBFlagsRdy = flags_rdy;
 3982              		.loc 1 1053 0
 3983 1550 14301BE5 		ldr	r3, [fp, #-20]
 3984 1554 BA215BE1 		ldrh	r2, [fp, #-26]	@ movhi
 3985 1558 B822C3E1 		strh	r2, [r3, #40]	@ movhi
1054:../os_port/os_flag.c ****     ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
 3986              		.loc 1 1054 0
 3987 155c 14301BE5 		ldr	r3, [fp, #-20]
 3988 1560 2C30D3E5 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 3989 1564 2030C3E3 		bic	r3, r3, #32
 3990 1568 FF2003E2 		and	r2, r3, #255
 3991 156c 14301BE5 		ldr	r3, [fp, #-20]
 3992 1570 2C20C3E5 		strb	r2, [r3, #44]
1055:../os_port/os_flag.c ****     ptcb->OSTCBPendTO   = FALSE;
 3993              		.loc 1 1055 0
 3994 1574 14301BE5 		ldr	r3, [fp, #-20]
 3995 1578 0020A0E3 		mov	r2, #0
 3996 157c 2D20C3E5 		strb	r2, [r3, #45]
1056:../os_port/os_flag.c ****     if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                      
 3997              		.loc 1 1056 0
 3998 1580 14301BE5 		ldr	r3, [fp, #-20]
 3999 1584 2C30D3E5 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 4000 1588 000053E3 		cmp	r3, #0
 4001 158c 1600001A 		bne	.L136
1057:../os_port/os_flag.c ****         OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list             
 4002              		.loc 1 1057 0
 4003 1590 14301BE5 		ldr	r3, [fp, #-20]
 4004 1594 3220D3E5 		ldrb	r2, [r3, #50]	@ zero_extendqisi2
 4005 1598 70309FE5 		ldr	r3, .L138
 4006 159c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4007 15a0 033082E1 		orr	r3, r2, r3
 4008 15a4 FF2003E2 		and	r2, r3, #255
 4009 15a8 60309FE5 		ldr	r3, .L138
 4010 15ac 0020C3E5 		strb	r2, [r3, #0]
1058:../os_port/os_flag.c ****         OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 4011              		.loc 1 1058 0
 4012 15b0 14301BE5 		ldr	r3, [fp, #-20]
 4013 15b4 3030D3E5 		ldrb	r3, [r3, #48]	@ zero_extendqisi2
 4014 15b8 14201BE5 		ldr	r2, [fp, #-20]
 4015 15bc 3020D2E5 		ldrb	r2, [r2, #48]	@ zero_extendqisi2
 4016 15c0 4C109FE5 		ldr	r1, .L138+4
 4017 15c4 0210D1E7 		ldrb	r1, [r1, r2]	@ zero_extendqisi2
 4018 15c8 14201BE5 		ldr	r2, [fp, #-20]
 4019 15cc 3120D2E5 		ldrb	r2, [r2, #49]	@ zero_extendqisi2
 4020 15d0 022081E1 		orr	r2, r1, r2
 4021 15d4 FF1002E2 		and	r1, r2, #255
 4022 15d8 34209FE5 		ldr	r2, .L138+4
 4023 15dc 0310C2E7 		strb	r1, [r2, r3]
1059:../os_port/os_flag.c ****         sched                   = TRUE;
 4024              		.loc 1 1059 0
 4025 15e0 0130A0E3 		mov	r3, #1
 4026 15e4 0D304BE5 		strb	r3, [fp, #-13]
 4027 15e8 010000EA 		b	.L137
 4028              	.L136:
1060:../os_port/os_flag.c ****     } else {
1061:../os_port/os_flag.c ****         sched                   = FALSE;
 4029              		.loc 1 1061 0
 4030 15ec 0030A0E3 		mov	r3, #0
 4031 15f0 0D304BE5 		strb	r3, [fp, #-13]
 4032              	.L137:
1062:../os_port/os_flag.c ****     }
1063:../os_port/os_flag.c ****     OS_FlagUnlink(pnode);
 4033              		.loc 1 1063 0
 4034 15f4 18001BE5 		ldr	r0, [fp, #-24]
 4035 15f8 FEFFFFEB 		bl	OS_FlagUnlink
1064:../os_port/os_flag.c ****     return (sched);
 4036              		.loc 1 1064 0
 4037 15fc 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
1065:../os_port/os_flag.c **** }
 4038              		.loc 1 1065 0
 4039 1600 0300A0E1 		mov	r0, r3
 4040 1604 0CD04BE2 		sub	sp, fp, #12
 4041 1608 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4042 160c 1EFF2FE1 		bx	lr
 4043              	.L139:
 4044              		.align	2
 4045              	.L138:
 4046 1610 00000000 		.word	OSRdyGrp
 4047 1614 00000000 		.word	OSRdyTbl
 4048              		.cfi_endproc
 4049              	.LFE11:
 4051              		.align	2
 4052              		.global	OS_FlagUnlink
 4054              	OS_FlagUnlink:
 4055              	.LFB12:
1066:../os_port/os_flag.c **** 
1067:../os_port/os_flag.c **** /*$PAGE*/
1068:../os_port/os_flag.c **** /*
1069:../os_port/os_flag.c **** ***************************************************************************************************
1070:../os_port/os_flag.c **** *                                  UNLINK EVENT FLAG NODE FROM WAITING LIST
1071:../os_port/os_flag.c **** *
1072:../os_port/os_flag.c **** * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from 
1073:../os_port/os_flag.c **** *              list of tasks waiting for the event flag.
1074:../os_port/os_flag.c **** *
1075:../os_port/os_flag.c **** * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting
1076:../os_port/os_flag.c **** *                            event flag bit(s) to be set.
1077:../os_port/os_flag.c **** *
1078:../os_port/os_flag.c **** * Returns    : none
1079:../os_port/os_flag.c **** *
1080:../os_port/os_flag.c **** * Called by  : OS_FlagTaskRdy() OS_FLAG.C
1081:../os_port/os_flag.c **** *              OSFlagPend()     OS_FLAG.C
1082:../os_port/os_flag.c **** *              OSTaskDel()      OS_TASK.C
1083:../os_port/os_flag.c **** *
1084:../os_port/os_flag.c **** * Note(s)    : 1) This function assumes that interrupts are disabled.
1085:../os_port/os_flag.c **** *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
1086:../os_port/os_flag.c **** ***************************************************************************************************
1087:../os_port/os_flag.c **** */
1088:../os_port/os_flag.c **** 
1089:../os_port/os_flag.c **** void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
1090:../os_port/os_flag.c **** {
 4056              		.loc 1 1090 0
 4057              		.cfi_startproc
 4058              		@ Function supports interworking.
 4059              		@ args = 0, pretend = 0, frame = 24
 4060              		@ frame_needed = 1, uses_anonymous_args = 0
 4061 1618 0DC0A0E1 		mov	ip, sp
 4062              	.LCFI24:
 4063              		.cfi_def_cfa_register 12
 4064 161c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4065 1620 04B04CE2 		sub	fp, ip, #4
 4066              		.cfi_offset 14, -8
 4067              		.cfi_offset 13, -12
 4068              		.cfi_offset 11, -16
 4069              	.LCFI25:
 4070              		.cfi_def_cfa 11, 4
 4071 1624 18D04DE2 		sub	sp, sp, #24
 4072 1628 20000BE5 		str	r0, [fp, #-32]
1091:../os_port/os_flag.c **** #if OS_TASK_DEL_EN > 0
1092:../os_port/os_flag.c ****     OS_TCB       *ptcb;
1093:../os_port/os_flag.c **** #endif
1094:../os_port/os_flag.c ****     OS_FLAG_GRP  *pgrp;
1095:../os_port/os_flag.c ****     OS_FLAG_NODE *pnode_prev;
1096:../os_port/os_flag.c ****     OS_FLAG_NODE *pnode_next;
1097:../os_port/os_flag.c **** 
1098:../os_port/os_flag.c **** 
1099:../os_port/os_flag.c ****     pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 4073              		.loc 1 1099 0
 4074 162c 20301BE5 		ldr	r3, [fp, #-32]
 4075 1630 043093E5 		ldr	r3, [r3, #4]
 4076 1634 10300BE5 		str	r3, [fp, #-16]
1100:../os_port/os_flag.c ****     pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 4077              		.loc 1 1100 0
 4078 1638 20301BE5 		ldr	r3, [fp, #-32]
 4079 163c 003093E5 		ldr	r3, [r3, #0]
 4080 1640 14300BE5 		str	r3, [fp, #-20]
1101:../os_port/os_flag.c ****     if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?  
 4081              		.loc 1 1101 0
 4082 1644 10301BE5 		ldr	r3, [fp, #-16]
 4083 1648 000053E3 		cmp	r3, #0
 4084 164c 0C00001A 		bne	.L141
1102:../os_port/os_flag.c ****         pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 4085              		.loc 1 1102 0
 4086 1650 20301BE5 		ldr	r3, [fp, #-32]
 4087 1654 0C3093E5 		ldr	r3, [r3, #12]
 4088 1658 18300BE5 		str	r3, [fp, #-24]
1103:../os_port/os_flag.c ****         pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st nod
 4089              		.loc 1 1103 0
 4090 165c 18301BE5 		ldr	r3, [fp, #-24]
 4091 1660 14201BE5 		ldr	r2, [fp, #-20]
 4092 1664 042083E5 		str	r2, [r3, #4]
1104:../os_port/os_flag.c ****         if (pnode_next != (OS_FLAG_NODE *)0) {
 4093              		.loc 1 1104 0
 4094 1668 14301BE5 		ldr	r3, [fp, #-20]
 4095 166c 000053E3 		cmp	r3, #0
 4096 1670 0C00000A 		beq	.L142
1105:../os_port/os_flag.c ****             pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to N
 4097              		.loc 1 1105 0
 4098 1674 14301BE5 		ldr	r3, [fp, #-20]
 4099 1678 0020A0E3 		mov	r2, #0
 4100 167c 042083E5 		str	r2, [r3, #4]
 4101 1680 080000EA 		b	.L142
 4102              	.L141:
1106:../os_port/os_flag.c ****         }
1107:../os_port/os_flag.c ****     } else {                                                    /* No,  A node somewhere in the lis
1108:../os_port/os_flag.c ****         pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unl
 4103              		.loc 1 1108 0
 4104 1684 10301BE5 		ldr	r3, [fp, #-16]
 4105 1688 14201BE5 		ldr	r2, [fp, #-20]
 4106 168c 002083E5 		str	r2, [r3, #0]
1109:../os_port/os_flag.c ****         if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?    
 4107              		.loc 1 1109 0
 4108 1690 14301BE5 		ldr	r3, [fp, #-20]
 4109 1694 000053E3 		cmp	r3, #0
 4110 1698 0200000A 		beq	.L142
1110:../os_port/os_flag.c ****             pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current nod
 4111              		.loc 1 1110 0
 4112 169c 14301BE5 		ldr	r3, [fp, #-20]
 4113 16a0 10201BE5 		ldr	r2, [fp, #-16]
 4114 16a4 042083E5 		str	r2, [r3, #4]
 4115              	.L142:
1111:../os_port/os_flag.c ****         }
1112:../os_port/os_flag.c ****     }
1113:../os_port/os_flag.c **** #if OS_TASK_DEL_EN > 0
1114:../os_port/os_flag.c ****     ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 4116              		.loc 1 1114 0
 4117 16a8 20301BE5 		ldr	r3, [fp, #-32]
 4118 16ac 083093E5 		ldr	r3, [r3, #8]
 4119 16b0 1C300BE5 		str	r3, [fp, #-28]
1115:../os_port/os_flag.c ****     ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 4120              		.loc 1 1115 0
 4121 16b4 1C301BE5 		ldr	r3, [fp, #-28]
 4122 16b8 0020A0E3 		mov	r2, #0
 4123 16bc 242083E5 		str	r2, [r3, #36]
1116:../os_port/os_flag.c **** #endif
1117:../os_port/os_flag.c **** }
 4124              		.loc 1 1117 0
 4125 16c0 0CD04BE2 		sub	sp, fp, #12
 4126 16c4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4127 16c8 1EFF2FE1 		bx	lr
 4128              		.cfi_endproc
 4129              	.LFE12:
 4131              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 os_flag.c
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:1662   .text:00000000 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:1665   .text:00000000 OSFlagAccept
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:1755   .text:000000c8 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:1761   .text:000000d8 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:1981   .text:00000324 OSFlagCreate
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2099   .text:00000420 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2104   .text:00000428 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2107   .text:00000428 OSFlagDel
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3953   .text:0000151c OS_FlagTaskRdy
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2350   .text:00000660 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2355   .text:00000668 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2358   .text:00000668 OSFlagNameGet
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2483   .text:00000754 OSFlagNameSet
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2625   .text:0000085c OSFlagPend
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2723   .text:00000938 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:2729   .text:00000948 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3697   .text:00001278 OS_FlagBlock
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:4054   .text:00001618 OS_FlagUnlink
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3092   .text:00000d08 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3098   .text:00000d18 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3165   .text:00000dc0 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3170   .text:00000dc8 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3173   .text:00000dc8 OSFlagPendGetFlagsRdy
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3226   .text:00000e14 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3230   .text:00000e18 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3233   .text:00000e18 OSFlagPost
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3365   .text:00000f54 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3371   .text:00000f64 $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3611   .text:000011d8 OSFlagQuery
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3842   .text:00001420 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3848   .text:0000142c $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3851   .text:0000142c OS_FlagInit
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3945   .text:00001510 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:3951   .text:0000151c $a
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:4046   .text:00001610 $d
C:\Users\VUser\AppData\Local\Temp\ccTf2931.s:4051   .text:00001618 $a
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
OSIntNesting
OSFlagFreeList
OS_Sched
OS_StrCopy
OS_StrLen
OSTCBCur
OSRdyTbl
OSRdyGrp
OS_MemClr
OSFlagTbl
